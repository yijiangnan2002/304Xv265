
/home/svc-audio-dspsw/kymera_builds/builds/2021/kymera_2104281140/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_rtp_decode.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

84200000 <$_rtp_decode_create>:
}

/* ********************************** API functions ************************************* */

bool rtp_decode_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200000:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200002:	17 00       	r5 = r0 + Null;
84200004:	1a 09       	r8 = r1 + Null;
84200006:	20 09       	r6 = r2 + Null;
84200008:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420000a:	ff fd 02 f0 	call (m) 0x4e6;
8420000e:	3d e6 
84200010:	16 00       	r4 = r0 + Null;
bool rtp_decode_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
84200012:	4d 08       	r3 = r7 + Null;
84200014:	44 08       	r2 = r6 + Null;
84200016:	53 08       	r1 = r8 + Null;
84200018:	3a 00       	r0 = r5 + Null;
8420001a:	ff fd 01 f0 	call (m) 0x35a;
8420001e:	21 ea 
84200020:	10 04       	Null = r0 - Null;
84200022:	03 62       	if NE jump (m) Lc_rtp_decode_create_3;

84200024 <Lc_rtp_decode_create_2>:
    {
        return FALSE;
84200024:	02 00       	r0 = Null + Null;
84200026:	14 6e       	jump (m) Lc_rtp_decode_create_4;

84200028 <Lc_rtp_decode_create_3>:
    }

    /* Make sure the input and output buffer is null. */
    opx_data->ip_buffer = NULL;
84200028:	70 9f       	M[r4 + 52] = Null;
    opx_data->op_buffer = NULL;
8420002a:	b0 9f       	M[r4 + 56] = Null;

    /* Reset the first tag logic.*/
    opx_data->continuation_for_frame = FALSE;
8420002c:	b0 8f       	M[r4 + 24] = Null;

    opx_data->latency_buffer_size = RTP_DECODE_DEFAULT_BUFFER_SIZE;
8420002e:	01 f0 00 42 	rMAC = Null + 512;
84200032:	f1 ae       	M[r4 + 76] = rMAC;
    opx_data->kick_on_full_output = FALSE;
84200034:	70 be       	M[r4 + 100] = Null;

    opx_data->aac_codec = NULL;
84200036:	70 8f       	M[r4 + 20] = Null;

    opx_data->max_packet_len = 0;
84200038:	70 af       	M[r4 + 84] = Null;
    opx_data->last_toa_valid = FALSE;
8420003a:	f0 af       	M[r4 + 92] = Null;
    opx_data->last_op_tag_octets = opx_data->max_packet_len;
8420003c:	30 be       	M[r4 + 96] = Null;

    opx_data->prev_src_id = SRC_ID_INVALID;
8420003e:	bc fa 81 f6 	rMAC = Null + -1412623820;
84200042:	34 62 
84200044:	31 bf       	M[r4 + 112] = rMAC;
    /* Initialise specific data (was allocated and pointer to it filled by OpMgr  */
    rtp_decode_reset_working_data(op_data);
84200046:	3a 00       	r0 = r5 + Null;
84200048:	06 f0 35 e1 	call (m) Lc_rtp_decode_reset_working_data_1;

    return TRUE;
8420004c:	42 20       	r0 = Null + 1;

8420004e <Lc_rtp_decode_create_4>:
}
8420004e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200050:	d8 4c       	rts;

84200052 <$_rtp_decode_destroy>:


bool rtp_decode_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200052:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200054:	16 00       	r4 = r0 + Null;
84200056:	1a 09       	r8 = r1 + Null;
84200058:	20 09       	r6 = r2 + Null;
8420005a:	2f 00       	r5 = r3 + Null;
    /* check that we are not trying to destroy a running operator */
    if (opmgr_op_is_running(op_data))
8420005c:	ff fd 2b f0 	call (m) 0x5700;
84200060:	25 e5 
84200062:	10 04       	Null = r0 - Null;
84200064:	09 60       	if EQ jump (m) Lc_rtp_decode_destroy_3;

84200066 <Lc_rtp_decode_destroy_2>:
    {
        /* We can't destroy a running operator. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200066:	03 f0 00 60 	r1 = Null + 4096;
8420006a:	3c 00       	r2 = r5 + Null;
8420006c:	32 00       	r0 = r4 + Null;
8420006e:	ff fd 02 f0 	call (m) 0x4bc;
84200072:	2f e2 
84200074:	21 6e       	jump (m) Lc_rtp_decode_destroy_7;

84200076 <Lc_rtp_decode_destroy_3>:
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200076:	32 00       	r0 = r4 + Null;
84200078:	ff fd 02 f0 	call (m) 0x4e6;
8420007c:	2f e3 
8420007e:	11 09       	r7 = r0 + Null;
    else
    {
        RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

        /* Delete the time to play instance*/
        ttp_free(opx_data->ttp_instance);
84200080:	92 f0 12 88 	r0 = M[r7 + 72];
84200084:	ff fd cd f0 	call (m) 0x19b54;
84200088:	31 e6 

        if ((opx_data->codec_type == AAC) && (opx_data->aac_codec != NULL))
8420008a:	91 f0 11 80 	rMAC = MBS[r7 + 17];
8420008e:	08 25       	Null = rMAC - 4;
84200090:	07 62       	if NE jump (m) Lc_rtp_decode_destroy_6;

84200092 <Lc_rtp_decode_destroy_4>:
84200092:	92 f0 05 88 	r0 = M[r7 + 20];
84200096:	04 60       	if EQ jump (m) Lc_rtp_decode_destroy_6;

84200098 <Lc_rtp_decode_destroy_5>:
        {
            aacdec_destroy_dummy_decoder(opx_data->aac_codec);
84200098:	ff fd c1 f3 	call 0x783e0;
8420009c:	28 ea 

8420009e <Lc_rtp_decode_destroy_6>:
        }
        pfree(opx_data->src_latency_map);
8420009e:	92 f0 1b 88 	r0 = M[r7 + 108];
842000a2:	ff fd 34 f0 	call (m) 0x68d8;
842000a6:	37 e1 

        /* call base_op destroy that creates and fills response message, too */
        return base_op_destroy(op_data, message_data, response_id, response_data);
842000a8:	3d 00       	r3 = r5 + Null;
842000aa:	44 08       	r2 = r6 + Null;
842000ac:	53 08       	r1 = r8 + Null;
842000ae:	32 00       	r0 = r4 + Null;
842000b0:	ff fd 01 f0 	call (m) 0x370;
842000b4:	21 e6 

842000b6 <Lc_rtp_decode_destroy_7>:
    }
}
842000b6:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842000b8:	d8 4c       	rts;

842000ba <$_rtp_decode_start>:

bool rtp_decode_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842000ba:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842000bc:	17 00       	r5 = r0 + Null;
842000be:	19 09       	r7 = r1 + Null;
842000c0:	20 09       	r6 = r2 + Null;
842000c2:	2e 00       	r4 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842000c4:	ff fd 02 f0 	call (m) 0x4e6;
842000c8:	23 e1 
842000ca:	12 09       	r8 = r0 + Null;

bool rtp_decode_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

    if ((opx_data->mode == RTP_DECODE)  || (opx_data->mode == RTP_TTP_ONLY))
842000cc:	a1 f0 08 80 	rMAC = MBS[r8 + 8];
842000d0:	48 24       	Null = rMAC - 1;
842000d2:	03 60       	if EQ jump (m) Lc_rtp_decode_start_3;

842000d4 <Lc_rtp_decode_start_2>:
842000d4:	c8 24       	Null = rMAC - 3;
842000d6:	23 62       	if NE jump (m) Lc_rtp_decode_start_10;

842000d8 <Lc_rtp_decode_start_3>:
    {
        /* Check if the sample rate is different than zero. */
        if(opx_data->sample_rate == 0)
842000d8:	a0 f0 14 88 	Null = M[r8 + 80];
842000dc:	09 62       	if NE jump (m) Lc_rtp_decode_start_5;

842000de <Lc_rtp_decode_start_4>:
        {
            return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842000de:	03 f0 00 60 	r1 = Null + 4096;
842000e2:	34 00       	r2 = r4 + Null;
842000e4:	3a 00       	r0 = r5 + Null;
842000e6:	ff fd 01 f0 	call (m) 0x4bc;
842000ea:	37 ee 
842000ec:	1f 6e       	jump (m) Lc_rtp_decode_start_11;

842000ee <Lc_rtp_decode_start_5>:
        }
    }

    if((opx_data->mode == RTP_DECODE) && (opx_data->codec_type == AAC) && (opx_data->aac_codec == NULL))
842000ee:	48 24       	Null = rMAC - 1;
842000f0:	16 62       	if NE jump (m) Lc_rtp_decode_start_10;

842000f2 <Lc_rtp_decode_start_6>:
842000f2:	a1 f0 11 80 	rMAC = MBS[r8 + 17];
842000f6:	08 25       	Null = rMAC - 4;
842000f8:	12 62       	if NE jump (m) Lc_rtp_decode_start_10;

842000fa <Lc_rtp_decode_start_7>:
842000fa:	a1 f0 05 88 	rMAC = M[r8 + 20];
842000fe:	0f 62       	if NE jump (m) Lc_rtp_decode_start_10;

84200100 <Lc_rtp_decode_start_8>:
    {
        /* It is very hard to decode and AAC frame to get the sample count. Therefore
         * RTP decode needs the help of a dummy AAC decoder created here. */
        opx_data->aac_codec = aacdec_create_dummy_decoder();
84200100:	ff fd c1 f3 	call 0x78308;
84200104:	28 e0 
        if(opx_data->aac_codec == NULL)
84200106:	a2 f0 05 8e 	M[r8 + 20] = r0;
8420010a:	09 62       	if NE jump (m) Lc_rtp_decode_start_10;

8420010c <Lc_rtp_decode_start_9>:
        {
            return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
8420010c:	03 f0 00 60 	r1 = Null + 4096;
84200110:	34 00       	r2 = r4 + Null;
84200112:	3a 00       	r0 = r5 + Null;
84200114:	ff fd 01 f0 	call (m) 0x4bc;
84200118:	29 ed 
8420011a:	08 6e       	jump (m) Lc_rtp_decode_start_11;

8420011c <Lc_rtp_decode_start_10>:
        }
    }

    return base_op_start(op_data, message_data, response_id, response_data);
8420011c:	35 00       	r3 = r4 + Null;
8420011e:	44 08       	r2 = r6 + Null;
84200120:	4b 08       	r1 = r7 + Null;
84200122:	3a 00       	r0 = r5 + Null;
84200124:	ff fd 01 f0 	call (m) 0x338;
84200128:	35 e0 

8420012a <Lc_rtp_decode_start_11>:
}
8420012a:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420012c:	d8 4c       	rts;

8420012e <$_rtp_decode_reset>:

bool rtp_decode_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420012e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84200130:	16 00       	r4 = r0 + Null;
    if (!base_op_reset(op_data, message_data, response_id, response_data))
84200132:	ff fd 00 f0 	call (m) 0x32c;
84200136:	3b ef 
84200138:	10 04       	Null = r0 - Null;
8420013a:	03 62       	if NE jump (m) Lc_rtp_decode_reset_3;

8420013c <Lc_rtp_decode_reset_2>:
    {
        return FALSE;
8420013c:	02 00       	r0 = Null + Null;
8420013e:	05 6e       	jump (m) Lc_rtp_decode_reset_4;

84200140 <Lc_rtp_decode_reset_3>:
    }

    /* now initialise specific working data */
    rtp_decode_reset_working_data(op_data);
84200140:	32 00       	r0 = r4 + Null;
84200142:	05 f0 3b e9 	call (m) Lc_rtp_decode_reset_working_data_1;

    return TRUE;
84200146:	42 20       	r0 = Null + 1;

84200148 <Lc_rtp_decode_reset_4>:
}
84200148:	f1 48       	popm <FP, r4, rLink>;
8420014a:	d8 4c       	rts;

8420014c <$_rtp_decode_connect>:

    return buffer;
}

bool rtp_decode_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420014c:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420014e:	11 09       	r7 = r0 + Null;
84200150:	18 09       	r6 = r1 + Null;
84200152:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200154:	ff fd 01 f0 	call (m) 0x4e6;
84200158:	33 ec 
8420015a:	17 00       	r5 = r0 + Null;
}

bool rtp_decode_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
8420015c:	86 f0 00 e8 	r4 = M[r6 + Null];
    unsigned  channel;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200160:	03 00       	r1 = Null + Null;
84200162:	54 08       	r2 = r8 + Null;
84200164:	4a 08       	r0 = r7 + Null;
84200166:	ff fd 01 f0 	call (m) 0x4bc;
8420016a:	37 ea 
8420016c:	10 04       	Null = r0 - Null;
8420016e:	03 62       	if NE jump (m) Lc_rtp_decode_connect_3;

84200170 <Lc_rtp_decode_connect_2>:
    {
        /* Shouldn't change anything if there is not enough memory for the response.*/
        return FALSE;
84200170:	02 00       	r0 = Null + Null;
84200172:	68 6e       	jump (m) Lc_rtp_decode_connect_17;

84200174 <Lc_rtp_decode_connect_3>:
    }

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
84200174:	bf ff 61 ff 	rMAC = r4 AND 0xff7fffff;
84200178:	ff 1f 
8420017a:	07 60       	if EQ jump (m) Lc_rtp_decode_connect_5;

8420017c <Lc_rtp_decode_connect_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420017c:	01 f0 03 60 	rMAC = Null + 4099;
84200180:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200184:	51 8e       	M[r0 + 4] = rMAC;
84200186:	5d 6e       	jump (m) Lc_rtp_decode_connect_16;

84200188 <Lc_rtp_decode_connect_5>:
    {
    	base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    if (terminal_id & TERMINAL_SINK_MASK)
84200188:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
8420018c:	00 00 
8420018e:	07 60       	if EQ jump (m) Lc_rtp_decode_connect_8;

84200190 <Lc_rtp_decode_connect_6>:
    {
        if (opx_data->ip_buffer == NULL)
84200190:	79 99       	rMAC = M[r5 + 52];
84200192:	3d 62       	if NE jump (m) Lc_rtp_decode_connect_13;

84200194 <Lc_rtp_decode_connect_7>:
        {
            /* Wrap up the given buffer to achieve octet based access to it. */
            opx_data->ip_buffer = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
84200194:	81 f0 01 88 	rMAC = M[r6 + 4];
84200198:	79 9f       	M[r5 + 52] = rMAC;
8420019a:	53 6e       	jump (m) Lc_rtp_decode_connect_16;

8420019c <Lc_rtp_decode_connect_8>:
            return TRUE;
        }
    }
    else
    {
        if (opx_data->op_buffer == NULL)
8420019c:	b9 99       	rMAC = M[r5 + 56];
8420019e:	37 62       	if NE jump (m) Lc_rtp_decode_connect_13;

842001a0 <Lc_rtp_decode_connect_9>:
        {
            tCbuffer *connection_buf = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
842001a0:	86 f0 01 88 	r4 = M[r6 + 4];
            /* Wrap up the given buffer to achieve octet based access to it. */
            opx_data->op_buffer = connection_buf;
842001a4:	be 9f       	M[r5 + 56] = r4;
            cbuffer_set_usable_octets(opx_data->op_buffer, ENCODED_DATA_OCTETS_IN_WORD);
842001a6:	03 21       	r1 = Null + 4;
842001a8:	32 00       	r0 = r4 + Null;
842001aa:	ff fd a0 f0 	call (m) 0x1432e;
842001ae:	25 ec 
            {

                if (opx_data->pack_latency_buffer)
842001b0:	b8 b8       	Null = M[r5 + 104];
842001b2:	33 60       	if EQ jump (m) Lc_rtp_decode_connect_14;

842001b4 <Lc_rtp_decode_connect_10>:
                    opx_data->u.pack.frame_buffer = rtp_create_internal_buffer(
                            NULL,/* Create a new buffer for decoding the rtp payload. */
                            cbuffer_get_size_in_words(connection_buf),
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD)
                    );
842001b4:	32 00       	r0 = r4 + Null;
842001b6:	ff fd a1 f0 	call (m) 0x14450;
842001ba:	3b e4 
842001bc:	13 00       	r1 = r0 + Null;
842001be:	85 20       	r3 = Null + 2;
842001c0:	74 89       	r2 = M[r4 + 20];
842001c2:	02 00       	r0 = Null + Null;
842001c4:	07 f0 21 e1 	call (m) Lc_rtp_create_internal_buffer_1;
842001c8:	3a ae       	M[r5 + 64] = r0;
                    if(opx_data->u.pack.frame_buffer == NULL)
842001ca:	39 a8       	rMAC = M[r5 + 64];
842001cc:	20 60       	if EQ jump (m) Lc_rtp_decode_connect_13;

842001ce <Lc_rtp_decode_connect_11>:
                    opx_data->u.pack.clone_frame_buffer = rtp_create_internal_buffer(
                            opx_data->u.pack.frame_buffer->base_addr, /* clone buffer is only used to discard corrupt frames. */
                            cbuffer_get_size_in_words(connection_buf),
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD)
                    );
842001ce:	32 00       	r0 = r4 + Null;
842001d0:	ff fd a1 f0 	call (m) 0x14450;
842001d4:	21 e4 
842001d6:	13 00       	r1 = r0 + Null;
842001d8:	85 20       	r3 = Null + 2;
842001da:	74 89       	r2 = M[r4 + 20];
842001dc:	39 a8       	rMAC = M[r5 + 64];
842001de:	ca 88       	r0 = M[rMAC + 12];
842001e0:	07 f0 25 e0 	call (m) Lc_rtp_create_internal_buffer_1;
842001e4:	fa 9f       	M[r5 + 60] = r0;
                    if(opx_data->u.pack.clone_frame_buffer == NULL)
842001e6:	f9 99       	rMAC = M[r5 + 60];
842001e8:	12 60       	if EQ jump (m) Lc_rtp_decode_connect_13;

842001ea <Lc_rtp_decode_connect_12>:
                    {
                        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
                        return TRUE;
                    }
                    opx_data->u.pack.clone_frame_buffer->aux_ptr = (void*)(opx_data->u.pack.frame_buffer);
842001ea:	3a a8       	r0 = M[r5 + 64];
842001ec:	0a 8f       	M[rMAC + 16] = r0;
                    BUF_DESC_IN_PLACE_SET(opx_data->u.pack.clone_frame_buffer->descriptor); /* this is an inplace buffer. */
842001ee:	f9 99       	rMAC = M[r5 + 60];
842001f0:	09 29       	rMAC = rMAC + 20;
842001f2:	0a e8       	r0 = M[rMAC + Null];
842001f4:	d2 ce       	r0 = r0 OR 0x10000;
842001f6:	0a ee       	M[rMAC + Null] = r0;
                    opx_data->u.pack.internal_buffer = rtp_create_internal_buffer(
                            NULL, /* Create a new buffer */
                            opx_data->latency_buffer_size/2, /* Due to packing use half of the size. */
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_32BIT_PER_WORD)
                    );
842001f8:	05 21       	r3 = Null + 4;
842001fa:	74 89       	r2 = M[r4 + 20];
842001fc:	fa a8       	r0 = M[r5 + 76];
842001fe:	13 50       	r1 = r0 LSHIFT -1;
84200200:	02 00       	r0 = Null + Null;
84200202:	06 f0 23 ef 	call (m) Lc_rtp_create_internal_buffer_1;
84200206:	7a ae       	M[r5 + 68] = r0;
                    if(opx_data->u.pack.internal_buffer == NULL)
84200208:	79 a8       	rMAC = M[r5 + 68];
8420020a:	1b 62       	if NE jump (m) Lc_rtp_decode_connect_16;

8420020c <Lc_rtp_decode_connect_13>:
8420020c:	01 f0 00 60 	rMAC = Null + 4096;
84200210:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200214:	51 8e       	M[r0 + 4] = rMAC;
84200216:	15 6e       	jump (m) Lc_rtp_decode_connect_16;

84200218 <Lc_rtp_decode_connect_14>:
                    /* Now, clone the buffer which will be used internally. Make it an in-place
                     * buffer to save place and to avoid overwriting data. Note the output
                     * buffer is not in-place just the internal one. Also the clone buffer
                     * does not need to hold any metadata, it is only used to comfortably play
                     * with the output buffer.  */
                    buffer_flags = connection_buf->descriptor;
84200218:	68 f0 05 88 	r6 = M[r4 + 20];
                    BUF_DESC_IN_PLACE_SET(buffer_flags);
8420021c:	00 f1 00 f8 	r6 = r6 OR 0x10000;
84200220:	58 d8 
                    in_place_buffer = cbuffer_create( connection_buf->base_addr,
                                cbuffer_get_size_in_words(connection_buf), buffer_flags);
84200222:	32 00       	r0 = r4 + Null;
84200224:	ff fd a1 f0 	call (m) 0x14450;
84200228:	2d e1 
8420022a:	13 00       	r1 = r0 + Null;
8420022c:	f2 88       	r0 = M[r4 + 12];
8420022e:	44 08       	r2 = r6 + Null;
84200230:	ff fd a0 f0 	call (m) 0x1429c;
84200234:	2d e3 
                    if(in_place_buffer == NULL)
84200236:	10 04       	Null = r0 - Null;
84200238:	ea 61       	if EQ jump (m) Lc_rtp_decode_connect_13;

8420023a <Lc_rtp_decode_connect_15>:
                    {
                        base_op_change_response_status(response_data, STATUS_CMD_FAILED);

                        return TRUE;
                    }
                    opx_data->u.clone_op_buffer = in_place_buffer;
8420023a:	fa 9f       	M[r5 + 60] = r0;
                    opx_data->u.clone_op_buffer->aux_ptr = (void*)opx_data->op_buffer;
8420023c:	b9 99       	rMAC = M[r5 + 56];
8420023e:	11 8f       	M[r0 + 16] = rMAC;

84200240 <Lc_rtp_decode_connect_16>:

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
    {
    	base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84200240:	42 20       	r0 = Null + 1;

84200242 <Lc_rtp_decode_connect_17>:
        }
    }


    return TRUE;
}
84200242:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200244:	d8 4c       	rts;

84200246 <$_rtp_decode_disconnect>:


bool rtp_decode_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200246:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200248:	11 09       	r7 = r0 + Null;
8420024a:	1f 00       	r5 = r1 + Null;
8420024c:	28 09       	r6 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420024e:	ff fd 01 f0 	call (m) 0x4e6;
84200252:	39 e4 
84200254:	16 00       	r4 = r0 + Null;


bool rtp_decode_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
84200256:	3f e8       	r5 = M[r5 + Null];
    unsigned channel;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200258:	03 00       	r1 = Null + Null;
8420025a:	44 08       	r2 = r6 + Null;
8420025c:	4a 08       	r0 = r7 + Null;
8420025e:	ff fd 01 f0 	call (m) 0x4bc;
84200262:	3f e2 
84200264:	10 04       	Null = r0 - Null;
84200266:	03 62       	if NE jump (m) Lc_rtp_decode_disconnect_3;

84200268 <Lc_rtp_decode_disconnect_2>:
    {
        /* Shouldn't change anything if there is not enough memory for the response.*/
        return FALSE;
84200268:	02 00       	r0 = Null + Null;
8420026a:	2a 6e       	jump (m) Lc_rtp_decode_disconnect_11;

8420026c <Lc_rtp_decode_disconnect_3>:
    }

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
8420026c:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
84200270:	ff 1f 
84200272:	07 60       	if EQ jump (m) Lc_rtp_decode_disconnect_5;

84200274 <Lc_rtp_decode_disconnect_4>:
84200274:	01 f0 03 60 	rMAC = Null + 4099;
84200278:	82 f0 00 e8 	r0 = M[r6 + Null];
8420027c:	51 8e       	M[r0 + 4] = rMAC;
8420027e:	1f 6e       	jump (m) Lc_rtp_decode_disconnect_10;

84200280 <Lc_rtp_decode_disconnect_5>:
    	base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }


    if (terminal_id & TERMINAL_SINK_MASK)
84200280:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200284:	00 00 
84200286:	03 60       	if EQ jump (m) Lc_rtp_decode_disconnect_7;

84200288 <Lc_rtp_decode_disconnect_6>:
    {
        opx_data->ip_buffer = NULL;
84200288:	70 9f       	M[r4 + 52] = Null;
8420028a:	19 6e       	jump (m) Lc_rtp_decode_disconnect_10;

8420028c <Lc_rtp_decode_disconnect_7>:
    }
    else
    {
        opx_data->op_buffer = NULL;
8420028c:	b0 9f       	M[r4 + 56] = Null;
        if (opx_data->pack_latency_buffer)
8420028e:	b0 b8       	Null = M[r4 + 104];
84200290:	11 60       	if EQ jump (m) Lc_rtp_decode_disconnect_9;

84200292 <Lc_rtp_decode_disconnect_8>:
        {
            /* Destroy the internal buffer */
            cbuffer_destroy(opx_data->u.pack.internal_buffer);
84200292:	72 a8       	r0 = M[r4 + 68];
84200294:	ff fd a0 f0 	call (m) 0x1439a;
84200298:	27 e8 
            opx_data->u.pack.internal_buffer = NULL;
8420029a:	70 ae       	M[r4 + 68] = Null;

            /* Only destroy the buffer struct, the buffer be freed with opx_data->u.pack.frame_buffer */
            cbuffer_destroy_struct(opx_data->u.pack.clone_frame_buffer);
8420029c:	f2 99       	r0 = M[r4 + 60];
8420029e:	ff fd a0 f0 	call (m) 0x143cc;
842002a2:	2f e9 
            opx_data->u.pack.clone_frame_buffer = NULL;
842002a4:	f0 9f       	M[r4 + 60] = Null;

            cbuffer_destroy(opx_data->u.pack.frame_buffer);
842002a6:	32 a8       	r0 = M[r4 + 64];
842002a8:	ff fd a0 f0 	call (m) 0x1439a;
842002ac:	33 e7 
            opx_data->u.pack.frame_buffer = NULL;
842002ae:	30 ae       	M[r4 + 64] = Null;
842002b0:	06 6e       	jump (m) Lc_rtp_decode_disconnect_10;

842002b2 <Lc_rtp_decode_disconnect_9>:
        }
        else
        {
            cbuffer_destroy_struct(opx_data->u.clone_op_buffer);
842002b2:	f2 99       	r0 = M[r4 + 60];
842002b4:	ff fd a0 f0 	call (m) 0x143cc;
842002b8:	39 e8 
            opx_data->u.clone_op_buffer = NULL;
842002ba:	f0 9f       	M[r4 + 60] = Null;

842002bc <Lc_rtp_decode_disconnect_10>:

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
    {
    	base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
842002bc:	42 20       	r0 = Null + 1;

842002be <Lc_rtp_decode_disconnect_11>:
            opx_data->u.clone_op_buffer = NULL;
        }
    }

    return TRUE;
}
842002be:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842002c0:	d8 4c       	rts;

842002c2 <$_rtp_decode_buffer_details>:


bool rtp_decode_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842002c2:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842002c4:	11 09       	r7 = r0 + Null;
842002c6:	18 09       	r6 = r1 + Null;
842002c8:	22 09       	r8 = r2 + Null;
842002ca:	2e 00       	r4 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842002cc:	ff fd 01 f0 	call (m) 0x4e6;
842002d0:	3b e0 
842002d2:	17 00       	r5 = r0 + Null;


bool rtp_decode_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned *)message_data)[0];
842002d4:	8b f0 00 e8 	r9 = M[r6 + Null];

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
842002d8:	35 00       	r3 = r4 + Null;
842002da:	54 08       	r2 = r8 + Null;
842002dc:	43 08       	r1 = r6 + Null;
842002de:	4a 08       	r0 = r7 + Null;
842002e0:	ff fd 00 f0 	call (m) 0x37c;
842002e4:	3d e4 
842002e6:	10 04       	Null = r0 - Null;
842002e8:	03 62       	if NE jump (m) Lc_rtp_decode_buffer_details_3;

842002ea <Lc_rtp_decode_buffer_details_2>:
    {
        return FALSE;
842002ea:	02 00       	r0 = Null + Null;
842002ec:	19 6e       	jump (m) Lc_rtp_decode_buffer_details_8;

842002ee <Lc_rtp_decode_buffer_details_3>:
    }

    /* RTP does not reuse any of its metadata on other channels. */
    ((OP_BUF_DETAILS_RSP*)*response_data)->metadata_buffer = NULL;
842002ee:	31 e8       	rMAC = M[r4 + Null];
842002f0:	c8 8e       	M[rMAC + 12] = Null;

    /* Metadata on the output buffer is only present if the capability decodes the RTP
     * header but the working mode config message could arrive after the connect. */
    ((OP_BUF_DETAILS_RSP*)*response_data)->supports_metadata = TRUE;
842002f2:	31 e8       	rMAC = M[r4 + Null];
842002f4:	09 22       	rMAC = rMAC + 8;
842002f6:	0a e2       	r0 = MBU[rMAC + Null];
842002f8:	22 ff ef 1f 	r0 = r0 AND 0xffffffef;
842002fc:	d2 c9       	r0 = r0 OR 0x10;
842002fe:	0a ea       	MB[rMAC + Null] = r0;

    /* If the data is packed internaly, use the default output buffer size. */
    if ((!opx_data->pack_latency_buffer)&&((terminal_id & TERMINAL_SINK_MASK) == 0))
84200300:	b8 b8       	Null = M[r5 + 104];
84200302:	09 62       	if NE jump (m) Lc_rtp_decode_buffer_details_6;

84200304 <Lc_rtp_decode_buffer_details_4>:
84200304:	40 f0 b1 f0 	rMAC = r9 AND 0x800000;
84200308:	00 00 
8420030a:	05 62       	if NE jump (m) Lc_rtp_decode_buffer_details_6;

8420030c <Lc_rtp_decode_buffer_details_5>:
    {
        /* Output, use the latency buffer size */
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size = opx_data->latency_buffer_size;
8420030c:	f9 a8       	rMAC = M[r5 + 76];
8420030e:	32 e8       	r0 = M[r4 + Null];
84200310:	11 8f       	M[r0 + 16] = rMAC;
84200312:	05 6e       	jump (m) Lc_rtp_decode_buffer_details_7;

84200314 <Lc_rtp_decode_buffer_details_6>:
    }
    else
    {
        /* Default buffer size for input terminal */
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size = RTP_DECODE_DEFAULT_BUFFER_SIZE;
84200314:	01 f0 00 42 	rMAC = Null + 512;
84200318:	32 e8       	r0 = M[r4 + Null];
8420031a:	11 8f       	M[r0 + 16] = rMAC;

8420031c <Lc_rtp_decode_buffer_details_7>:
    }

    L4_DBG_MSG1("rtp_decode_buffer_details  %d \n", ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size  );

    return TRUE;
8420031c:	42 20       	r0 = Null + 1;

8420031e <Lc_rtp_decode_buffer_details_8>:
}
8420031e:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200320:	d8 4c       	rts;

84200322 <$_rtp_decode_get_sched_info>:


bool rtp_decode_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200322:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200324:	17 00       	r5 = r0 + Null;
84200326:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84200328:	ff fd 00 f0 	call (m) 0x41c;
8420032c:	35 e7 
    if (resp == NULL)
8420032e:	10 04       	Null = r0 - Null;
84200330:	09 62       	if NE jump (m) Lc_rtp_decode_get_sched_info_3;

84200332 <Lc_rtp_decode_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200332:	03 f0 00 60 	r1 = Null + 4096;
84200336:	34 00       	r2 = r4 + Null;
84200338:	3a 00       	r0 = r5 + Null;
8420033a:	ff fd 00 f0 	call (m) 0x4bc;
8420033e:	23 ec 
84200340:	05 6e       	jump (m) Lc_rtp_decode_get_sched_info_4;

84200342 <Lc_rtp_decode_get_sched_info_3>:
    }
    *response_data = resp;
84200342:	32 ee       	M[r4 + Null] = r0;

    /* Same buffer size for sink and source.
       No additional verification needed.*/
    resp->block_size = RTP_DECODE_DEFAULT_BLOCK_SIZE;
84200344:	41 20       	rMAC = Null + 1;
84200346:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
84200348:	0a 00       	r0 = rMAC + Null;

8420034a <Lc_rtp_decode_get_sched_info_4>:
}
8420034a:	f2 48       	popm <FP, r4, r5, rLink>;
8420034c:	d8 4c       	rts;

8420034e <$_rtp_decode_get_data_format>:


bool rtp_decode_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420034e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200350:	10 09       	r6 = r0 + Null;
84200352:	1a 09       	r8 = r1 + Null;
84200354:	21 09       	r7 = r2 + Null;
84200356:	2e 00       	r4 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200358:	ff fd 00 f0 	call (m) 0x4e6;
8420035c:	2f ec 
8420035e:	17 00       	r5 = r0 + Null;

bool rtp_decode_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if (!base_op_get_data_format(op_data, message_data, response_id, response_data))
84200360:	35 00       	r3 = r4 + Null;
84200362:	4c 08       	r2 = r7 + Null;
84200364:	53 08       	r1 = r8 + Null;
84200366:	42 08       	r0 = r6 + Null;
84200368:	ff fd 00 f0 	call (m) 0x43a;
8420036c:	33 e6 
8420036e:	10 04       	Null = r0 - Null;
84200370:	03 62       	if NE jump (m) Lc_rtp_decode_get_data_format_3;

84200372 <Lc_rtp_decode_get_data_format_2>:
    {
        return FALSE;
84200372:	02 00       	r0 = Null + Null;
84200374:	0f 6e       	jump (m) Lc_rtp_decode_get_data_format_7;

84200376 <Lc_rtp_decode_get_data_format_3>:
    }

    /* return the terminal's data format - purely based on terminal data direction flag */
    if((OPMGR_GET_OP_DATA_FORMAT_TERMINAL_ID(message_data) & TERMINAL_SINK_MASK) == 0)
84200376:	a1 f0 00 e8 	rMAC = M[r8 + Null];
8420037a:	40 f0 11 f0 	rMAC = rMAC AND 0x800000;
8420037e:	00 00 
84200380:	05 62       	if NE jump (m) Lc_rtp_decode_get_data_format_5;

84200382 <Lc_rtp_decode_get_data_format_4>:
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = opx_data->op_format;
84200382:	79 88       	rMAC = M[r5 + 4];
84200384:	32 e8       	r0 = M[r4 + Null];
84200386:	91 8e       	M[r0 + 8] = rMAC;
84200388:	04 6e       	jump (m) Lc_rtp_decode_get_data_format_6;

8420038a <Lc_rtp_decode_get_data_format_5>:
    }
    else
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = opx_data->ip_format;
8420038a:	39 e8       	rMAC = M[r5 + Null];
8420038c:	32 e8       	r0 = M[r4 + Null];
8420038e:	91 8e       	M[r0 + 8] = rMAC;

84200390 <Lc_rtp_decode_get_data_format_6>:
    }

    return TRUE;
84200390:	42 20       	r0 = Null + 1;

84200392 <Lc_rtp_decode_get_data_format_7>:
}
84200392:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200394:	d8 4c       	rts;

84200396 <$_rtp_decode_opmsg_set_working_mode>:

/* **************************** Operator message handlers ******************************** */


bool rtp_decode_opmsg_set_working_mode(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200396:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84200398:	1f 00       	r5 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420039a:	ff fd 00 f0 	call (m) 0x4e6;
8420039e:	2d ea 
842003a0:	16 00       	r4 = r0 + Null;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_WORKING_MODES wm;

    wm = (RTP_WORKING_MODES) OPMSG_FIELD_GET(message_data,
                                OPMSG_RTP_SET_WORKING_MODE, WORKING_MODE);
842003a2:	f9 88       	rMAC = M[r5 + 12];
842003a4:	89 c6       	rMAC = rMAC AND 0xffff;
842003a6:	0f 08       	r5 = SE8 rMAC;

    if (wm >= RTP_NR_OF_MODES)
842003a8:	38 25       	Null = r5 - 4;
842003aa:	03 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_working_mode_3;

842003ac <Lc_rtp_decode_opmsg_set_working_mode_2>:
    {
        return FALSE;
842003ac:	02 00       	r0 = Null + Null;
842003ae:	19 6e       	jump (m) Lc_rtp_decode_opmsg_set_working_mode_9;

842003b0 <Lc_rtp_decode_opmsg_set_working_mode_3>:
    }

    /* Check a new time to play instance is needed. */
    if ((wm == RTP_DECODE)||(wm == RTP_TTP_ONLY))
842003b0:	78 24       	Null = r5 - 1;
842003b2:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_working_mode_5;

842003b4 <Lc_rtp_decode_opmsg_set_working_mode_4>:
842003b4:	f8 24       	Null = r5 - 3;
842003b6:	13 62       	if NE jump (m) Lc_rtp_decode_opmsg_set_working_mode_8;

842003b8 <Lc_rtp_decode_opmsg_set_working_mode_5>:
    {
        if (opx_data->ttp_instance == NULL)
842003b8:	b1 a8       	rMAC = M[r4 + 72];
842003ba:	11 62       	if NE jump (m) Lc_rtp_decode_opmsg_set_working_mode_8;

842003bc <Lc_rtp_decode_opmsg_set_working_mode_6>:
        {
            ttp_params params;

            /* Create a new ttp instance*/
            opx_data->ttp_instance = ttp_init();
842003bc:	ff fd c8 f0 	call (m) 0x19462;
842003c0:	27 e5 
842003c2:	b2 ae       	M[r4 + 72] = r0;
            if (opx_data->ttp_instance == NULL)
842003c4:	b1 a8       	rMAC = M[r4 + 72];
842003c6:	f3 61       	if EQ jump (m) Lc_rtp_decode_opmsg_set_working_mode_2;

842003c8 <Lc_rtp_decode_opmsg_set_working_mode_7>:
            {
                return FALSE;
            }

            ttp_get_default_params(&params, TTP_TYPE_A2DP);
842003c8:	83 20       	r1 = Null + 2;
842003ca:	02 11       	r0 = FP + 16;
842003cc:	ff fd c8 f0 	call (m) 0x194aa;
842003d0:	3f e6 
            ttp_configure_params(opx_data->ttp_instance, &params);
842003d2:	03 11       	r1 = FP + 16;
842003d4:	b2 a8       	r0 = M[r4 + 72];
842003d6:	ff fd c9 f0 	call (m) 0x195f0;
842003da:	3b e0 

842003dc <Lc_rtp_decode_opmsg_set_working_mode_8>:
        }
    }

    opx_data->mode = wm;
842003dc:	37 9a       	MB[r4 + 8] = r5;

    return TRUE;
842003de:	42 20       	r0 = Null + 1;

842003e0 <Lc_rtp_decode_opmsg_set_working_mode_9>:
}
842003e0:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
842003e2:	d8 4c       	rts;

842003e4 <$_rtp_decode_opmsg_set_codec_type>:


bool rtp_decode_opmsg_set_codec_type(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842003e4:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842003e6:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842003e8:	ff fd 00 f0 	call (m) 0x4e6;
842003ec:	3f e7 
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_CODEC_TYPE codec_type;

    codec_type = (RTP_CODEC_TYPE) OPMSG_FIELD_GET(message_data,
                                OPMSG_RTP_SET_CODEC_TYPE, CODEC_TYPE);
842003ee:	f1 88       	rMAC = M[r4 + 12];
842003f0:	89 c6       	rMAC = rMAC AND 0xffff;
842003f2:	09 08       	rMAC = SE8 rMAC;

    if (codec_type >= NR_OF_CODECS)
842003f4:	c8 25       	Null = rMAC - 7;
842003f6:	03 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_codec_type_3;

842003f8 <Lc_rtp_decode_opmsg_set_codec_type_2>:
    {
        return FALSE;
842003f8:	02 00       	r0 = Null + Null;
842003fa:	05 6e       	jump (m) Lc_rtp_decode_opmsg_set_codec_type_4;

842003fc <Lc_rtp_decode_opmsg_set_codec_type_3>:
    }

    opx_data->codec_type = codec_type;
842003fc:	51 aa       	MB[r0 + 17] = rMAC;

    rtp_set_payload_header_size(opx_data);
842003fe:	03 f0 3b e4 	call (m) Lc_rtp_set_payload_header_size_1;

    return TRUE;
84200402:	42 20       	r0 = Null + 1;

84200404 <Lc_rtp_decode_opmsg_set_codec_type_4>:
}
84200404:	f1 48       	popm <FP, r4, rLink>;
84200406:	d8 4c       	rts;

84200408 <$_rtp_decode_opmsg_set_content_protection>:


bool rtp_decode_opmsg_set_content_protection(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200408:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420040a:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420040c:	ff fd 00 f0 	call (m) 0x4e6;
84200410:	3b e6 
bool rtp_decode_opmsg_set_content_protection(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    opx_data->scms_enable = OPMSG_FIELD_GET(message_data,
                             OPMSG_RTP_SET_CONTENT_PROTECTION, CONTENT_PROTECTION_ENABLED) & 1;
84200412:	11 a2       	rMAC = MBU[r0 + 16];
84200414:	f3 88       	r1 = M[r4 + 12];
84200416:	11 ff fe 1f 	rMAC = rMAC AND 0xfffffffe;
8420041a:	1b c0       	r1 = r1 AND 0x1;
8420041c:	c9 12       	rMAC = rMAC OR r1;
8420041e:	11 aa       	MB[r0 + 16] = rMAC;

    return TRUE;
84200420:	42 20       	r0 = Null + 1;

84200422 <Lc_rtp_decode_opmsg_set_content_protection_2>:
}
84200422:	f1 48       	popm <FP, r4, rLink>;
84200424:	d8 4c       	rts;

84200426 <$_rtp_decode_opmsg_set_AAC_decoder>:

bool rtp_decode_opmsg_set_AAC_decoder(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200426:	c8 1c       	pushm <FP(=SP), rLink>;
    L2_DBG_MSG("received unnecessary SET_AAC_DECODER message" );
84200428:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420042c:	88 24       	Null = rMAC - 2;
8420042e:	07 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_AAC_decoder_3;

84200430 <Lc_rtp_decode_opmsg_set_AAC_decoder_2>:
84200430:	55 f1 02 f0 	r0 = Null + 357564780;
84200434:	6c 41 
84200436:	ff fd 04 f0 	call (m) 0xccc;
8420043a:	37 e4 

8420043c <Lc_rtp_decode_opmsg_set_AAC_decoder_3>:
    return TRUE;
8420043c:	42 20       	r0 = Null + 1;

8420043e <Lc_rtp_decode_opmsg_set_AAC_decoder_4>:
}
8420043e:	c8 48       	popm <FP, rLink>;
84200440:	d8 4c       	rts;

84200442 <$_rtp_decode_opmsg_set_AAC_utility>:

bool rtp_decode_opmsg_set_AAC_utility(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200442:	c8 1c       	pushm <FP(=SP), rLink>;
    L2_DBG_MSG("received unnecessary SET_AAC_UTILITY message" );
84200444:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200448:	88 24       	Null = rMAC - 2;
8420044a:	07 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_AAC_utility_3;

8420044c <Lc_rtp_decode_opmsg_set_AAC_utility_2>:
8420044c:	55 f1 02 f0 	r0 = Null + 357564825;
84200450:	99 41 
84200452:	ff fd 04 f0 	call (m) 0xccc;
84200456:	3b e3 

84200458 <Lc_rtp_decode_opmsg_set_AAC_utility_3>:
    return TRUE;
84200458:	42 20       	r0 = Null + 1;

8420045a <Lc_rtp_decode_opmsg_set_AAC_utility_4>:
}
8420045a:	c8 48       	popm <FP, rLink>;
8420045c:	d8 4c       	rts;

8420045e <$_rtp_decode_opmsg_set_max_packet_length>:

    return TRUE;
}

bool rtp_decode_opmsg_set_max_packet_length(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420045e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200460:	17 00       	r5 = r0 + Null;
84200462:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200464:	ff fd 00 f0 	call (m) 0x4e6;
84200468:	23 e4 
8420046a:	10 09       	r6 = r0 + Null;
}

bool rtp_decode_opmsg_set_max_packet_length(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    if (opmgr_op_is_running(op_data))
8420046c:	3a 00       	r0 = r5 + Null;
8420046e:	ff fd 29 f0 	call (m) 0x5700;
84200472:	33 e4 
84200474:	10 04       	Null = r0 - Null;
84200476:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_max_packet_length_3;

84200478 <Lc_rtp_decode_opmsg_set_max_packet_length_2>:
    {
        return FALSE;
84200478:	02 00       	r0 = Null + Null;
8420047a:	08 6e       	jump (m) Lc_rtp_decode_opmsg_set_max_packet_length_4;

8420047c <Lc_rtp_decode_opmsg_set_max_packet_length_3>:
    }
    else
    {
        opx_data->max_packet_len = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_MAX_PACKET_LENGTH, LENGTH);
8420047c:	f1 88       	rMAC = M[r4 + 12];
8420047e:	89 c6       	rMAC = rMAC AND 0xffff;
84200480:	81 f0 15 8e 	M[r6 + 84] = rMAC;
        opx_data->last_op_tag_octets = opx_data->max_packet_len;
84200484:	81 f0 18 8e 	M[r6 + 96] = rMAC;
        return TRUE;
84200488:	42 20       	r0 = Null + 1;

8420048a <Lc_rtp_decode_opmsg_set_max_packet_length_4>:
    }
}
8420048a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420048c:	d8 4c       	rts;

8420048e <$_rtp_decode_opmsg_set_packing>:
    opx_data->src_latency_map = src_latency_map;
    return TRUE;
}

bool rtp_decode_opmsg_set_packing(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420048e:	c8 1c       	pushm <FP(=SP), rLink>;
#ifdef DATAFORMAT_32
    L2_DBG_MSG("rtp_decode_opmsg_set_packing: DATAFORMAT_32 is enabled, there is no need to pack");
84200490:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200494:	88 24       	Null = rMAC - 2;
84200496:	07 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_packing_3;

84200498 <Lc_rtp_decode_opmsg_set_packing_2>:
84200498:	55 f1 02 f0 	r0 = Null + 357565033;
8420049c:	69 42 
8420049e:	ff fd 04 f0 	call (m) 0xccc;
842004a2:	2f e1 

842004a4 <Lc_rtp_decode_opmsg_set_packing_3>:
    return TRUE;
842004a4:	42 20       	r0 = Null + 1;

842004a6 <Lc_rtp_decode_opmsg_set_packing_4>:
            opx_data->pack_latency_buffer = FALSE;
        }
        return TRUE;
    }
#endif
}
842004a6:	c8 48       	popm <FP, rLink>;
842004a8:	d8 4c       	rts;

842004aa <$_rtp_decode_opmsg_set_src_latency_mapping>:
        return TRUE;
    }
}

bool rtp_decode_opmsg_set_src_latency_mapping(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842004aa:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842004ac:	17 00       	r5 = r0 + Null;
842004ae:	18 09       	r6 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842004b0:	ff fd 00 f0 	call (m) 0x4e6;
842004b4:	37 e1 
842004b6:	16 00       	r4 = r0 + Null;
bool rtp_decode_opmsg_set_src_latency_mapping(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_SRC_LATENCY_MAP *src_latency_map;
    unsigned count, num_entries, alloc_size;
    if (opmgr_op_is_running(op_data))
842004b8:	3a 00       	r0 = r5 + Null;
842004ba:	ff fd 29 f0 	call (m) 0x5700;
842004be:	27 e2 
842004c0:	10 04       	Null = r0 - Null;
842004c2:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_3;

842004c4 <Lc_rtp_decode_opmsg_set_src_latency_mapping_2>:
    {
        return FALSE;
842004c4:	02 00       	r0 = Null + Null;
842004c6:	2f 6e       	jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_9;

842004c8 <Lc_rtp_decode_opmsg_set_src_latency_mapping_3>:
    }
    num_entries = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, COUNT);
842004c8:	81 f0 03 88 	rMAC = M[r6 + 12];
842004cc:	8f c6       	r5 = rMAC AND 0xffff;
    alloc_size = sizeof(RTP_SRC_LATENCY_MAP) + num_entries * sizeof(RTP_SRC_LATENCY_MAP_ENTRY);
842004ce:	ba 54       	r0 = r5 LSHIFT 3;
842004d0:	12 21       	r0 = r0 + 4;
    src_latency_map = (RTP_SRC_LATENCY_MAP *)xpmalloc(alloc_size);
842004d2:	c3 20       	r1 = Null + 3;
842004d4:	ff fd 31 f0 	call (m) 0x67ac;
842004d8:	39 e6 
842004da:	11 09       	r7 = r0 + Null;
    if (src_latency_map == NULL)
842004dc:	f4 61       	if EQ jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_2;

842004de <Lc_rtp_decode_opmsg_set_src_latency_mapping_4>:
    {
        return FALSE;
    }
    src_latency_map->num_entries = num_entries;
842004de:	97 f0 00 ee 	M[r7 + Null] = r5;
    for (count = 0; count < num_entries; count++)
842004e2:	03 00       	r1 = Null + Null;
842004e4:	91 f0 04 20 	rMAC = r7 + 4;
842004e8:	82 f0 10 20 	r0 = r6 + 16;
842004ec:	d8 05       	Null = r1 - r5;
842004ee:	02 f0 a9 e0 	if C jump (m) Lc__loop0;

842004f2 <Lc_rtp_decode_opmsg_set_src_latency_mapping_5>:
842004f2:	3c 09       	r10 = r5 + Null;
842004f4:	11 4c       	do (m) Lc__loop0;

842004f6 <Lc_rtp_decode_opmsg_set_src_latency_mapping_6>:
    {
        src_latency_map->entries[count].source_id =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 1);
842004f6:	13 e8       	r1 = M[r0 + Null];
842004f8:	54 88       	r2 = M[r0 + 4];
842004fa:	9b c6       	r1 = r1 AND 0xffff;
842004fc:	a4 c6       	r2 = r2 AND 0xffff;
842004fe:	9b 56       	r1 = r1 LSHIFT 16;
84200500:	e3 00       	r1 = r2 + r1;
84200502:	0b ee       	M[rMAC + Null] = r1;
        src_latency_map->entries[count].target_latency =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 2) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 3);
84200504:	93 88       	r1 = M[r0 + 8];
84200506:	d4 88       	r2 = M[r0 + 12];
84200508:	9b c6       	r1 = r1 AND 0xffff;
8420050a:	a4 c6       	r2 = r2 AND 0xffff;
8420050c:	12 28       	r0 = r0 + 16;
8420050e:	9b 56       	r1 = r1 LSHIFT 16;
84200510:	e3 00       	r1 = r2 + r1;
84200512:	4b 8e       	M[rMAC + 4] = r1;
84200514:	09 22       	rMAC = rMAC + 8;

84200516 <Lc__loop0>:
    if (src_latency_map == NULL)
    {
        return FALSE;
    }
    src_latency_map->num_entries = num_entries;
    for (count = 0; count < num_entries; count++)
84200516:	f2 b8       	r0 = M[r4 + 108];
84200518:	ff fd 31 f0 	call (m) 0x68d8;
8420051c:	21 ee 
        src_latency_map->entries[count].target_latency =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 2) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 3);
    }
    pfree(opx_data->src_latency_map);
    opx_data->src_latency_map = src_latency_map;
8420051e:	69 f0 1b 8e 	M[r4 + 108] = r7;
    return TRUE;
84200522:	42 20       	r0 = Null + 1;

84200524 <Lc_rtp_decode_opmsg_set_src_latency_mapping_9>:
}
84200524:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200526:	d8 4c       	rts;

84200528 <$_rtp_decode_opmsg_set_ttp_latency>:
    L2_DBG_MSG("received unnecessary SET_AAC_UTILITY message" );
    return TRUE;
}

bool rtp_decode_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200528:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420052a:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420052c:	ef fd ff ff 	call (m) 0x4e6;
84200530:	3b ed 
84200532:	17 00       	r5 = r0 + Null;

bool rtp_decode_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if ((opx_data->mode !=RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200534:	39 90       	rMAC = MBS[r5 + 8];
84200536:	48 24       	Null = rMAC - 1;
84200538:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_4;

8420053a <Lc_rtp_decode_opmsg_set_ttp_latency_2>:
8420053a:	c8 24       	Null = rMAC - 3;
8420053c:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_4;

8420053e <Lc_rtp_decode_opmsg_set_ttp_latency_3>:
    {
        return FALSE;
8420053e:	02 00       	r0 = Null + Null;
84200540:	0b 6e       	jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_5;

84200542 <Lc_rtp_decode_opmsg_set_ttp_latency_4>:
    }

    ttp_configure_latency(opx_data->ttp_instance, ttp_get_msg_latency(message_data));
84200542:	32 00       	r0 = r4 + Null;
84200544:	ff fd c7 f0 	call (m) 0x194d2;
84200548:	2f ec 
8420054a:	13 00       	r1 = r0 + Null;
8420054c:	ba a8       	r0 = M[r5 + 72];
8420054e:	ff fd c8 f0 	call (m) 0x195a8;
84200552:	3b e2 
    return TRUE;
84200554:	42 20       	r0 = Null + 1;

84200556 <Lc_rtp_decode_opmsg_set_ttp_latency_5>:
}
84200556:	f2 48       	popm <FP, r4, r5, rLink>;
84200558:	d8 4c       	rts;

8420055a <$_rtp_decode_opmsg_set_ttp_state>:

bool rtp_decode_opmsg_set_ttp_state(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420055a:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
8420055c:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420055e:	ef fd ff ff 	call (m) 0x4e6;
84200562:	29 ec 
84200564:	17 00       	r5 = r0 + Null;
bool rtp_decode_opmsg_set_ttp_state(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    ttp_state_params state_params;

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200566:	39 90       	rMAC = MBS[r5 + 8];
84200568:	48 24       	Null = rMAC - 1;
8420056a:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_state_4;

8420056c <Lc_rtp_decode_opmsg_set_ttp_state_2>:
8420056c:	c8 24       	Null = rMAC - 3;
8420056e:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_state_4;

84200570 <Lc_rtp_decode_opmsg_set_ttp_state_3>:
    {
        return FALSE;
84200570:	02 00       	r0 = Null + Null;
84200572:	0a 6e       	jump (m) Lc_rtp_decode_opmsg_set_ttp_state_5;

84200574 <Lc_rtp_decode_opmsg_set_ttp_state_4>:
    }

    ttp_get_msg_state_params(&state_params, message_data);
84200574:	02 11       	r0 = FP + 16;
84200576:	33 00       	r1 = r4 + Null;
84200578:	08 f0 21 ed 	call (m) $_ttp_get_msg_state_params;
    ttp_configure_state_params(opx_data->ttp_instance, &state_params);
8420057c:	03 11       	r1 = FP + 16;
8420057e:	ba a8       	r0 = M[r5 + 72];
84200580:	08 f0 2d ed 	call (m) $_ttp_configure_state_params;
    return TRUE;
84200584:	42 20       	r0 = Null + 1;

84200586 <Lc_rtp_decode_opmsg_set_ttp_state_5>:
}
84200586:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
84200588:	d8 4c       	rts;

8420058a <$_rtp_decode_opmsg_set_latency_limits>:

bool rtp_decode_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420058a:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
8420058c:	1f 00       	r5 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420058e:	ef fd ff ff 	call (m) 0x4e6;
84200592:	39 ea 
84200594:	16 00       	r4 = r0 + Null;
bool rtp_decode_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    TIME_INTERVAL min_latency, max_latency;

    if ((opx_data->mode !=RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200596:	31 90       	rMAC = MBS[r4 + 8];
84200598:	48 24       	Null = rMAC - 1;
8420059a:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_latency_limits_4;

8420059c <Lc_rtp_decode_opmsg_set_latency_limits_2>:
8420059c:	c8 24       	Null = rMAC - 3;
8420059e:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_latency_limits_4;

842005a0 <Lc_rtp_decode_opmsg_set_latency_limits_3>:
    {
        return FALSE;
842005a0:	02 00       	r0 = Null + Null;
842005a2:	0e 6e       	jump (m) Lc_rtp_decode_opmsg_set_latency_limits_5;

842005a4 <Lc_rtp_decode_opmsg_set_latency_limits_4>:
    }
    ttp_get_msg_latency_limits(message_data, &min_latency, &max_latency);
842005a4:	44 11       	r2 = FP + 20;
842005a6:	03 11       	r1 = FP + 16;
842005a8:	3a 00       	r0 = r5 + Null;
842005aa:	ff fd c7 f0 	call (m) 0x19508;
842005ae:	3f ea 
    ttp_configure_latency_limits(opx_data->ttp_instance, min_latency, max_latency);
842005b0:	2c d8       	r2 = M[FP + 20];
842005b2:	23 d8       	r1 = M[FP + 16];
842005b4:	b2 a8       	r0 = M[r4 + 72];
842005b6:	ff fd c8 f0 	call (m) 0x195c8;
842005ba:	33 e0 

    return TRUE;
842005bc:	42 20       	r0 = Null + 1;

842005be <Lc_rtp_decode_opmsg_set_latency_limits_5>:
}
842005be:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
842005c0:	d8 4c       	rts;

842005c2 <$_rtp_decode_opmsg_set_ttp_params>:

bool rtp_decode_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005c2:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
842005c4:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842005c6:	ef fd ff ff 	call (m) 0x4e6;
842005ca:	21 e9 
842005cc:	17 00       	r5 = r0 + Null;
bool rtp_decode_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    ttp_params params;

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
842005ce:	39 90       	rMAC = MBS[r5 + 8];
842005d0:	48 24       	Null = rMAC - 1;
842005d2:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_params_4;

842005d4 <Lc_rtp_decode_opmsg_set_ttp_params_2>:
842005d4:	c8 24       	Null = rMAC - 3;
842005d6:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_params_4;

842005d8 <Lc_rtp_decode_opmsg_set_ttp_params_3>:
    {
        return FALSE;
842005d8:	02 00       	r0 = Null + Null;
842005da:	0c 6e       	jump (m) Lc_rtp_decode_opmsg_set_ttp_params_5;

842005dc <Lc_rtp_decode_opmsg_set_ttp_params_4>:
    }

    ttp_get_msg_params(&params, message_data);
842005dc:	02 11       	r0 = FP + 16;
842005de:	33 00       	r1 = r4 + Null;
842005e0:	ff fd c7 f0 	call (m) 0x19552;
842005e4:	33 eb 
    ttp_configure_params(opx_data->ttp_instance, &params);
842005e6:	03 11       	r1 = FP + 16;
842005e8:	ba a8       	r0 = M[r5 + 72];
842005ea:	ff fd c8 f0 	call (m) 0x195f0;
842005ee:	27 e0 

    return TRUE;
842005f0:	42 20       	r0 = Null + 1;

842005f2 <Lc_rtp_decode_opmsg_set_ttp_params_5>:
}
842005f2:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
842005f4:	d8 4c       	rts;

842005f6 <$_rtp_decode_opmsg_set_sample_rate>:


bool rtp_decode_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005f6:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842005f8:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842005fa:	ef fd ff ff 	call (m) 0x4e6;
842005fe:	2d e7 


bool rtp_decode_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned sample_rate = 25 * OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_SAMPLE_RATE, SAMPLE_RATE);
84200600:	f1 88       	rMAC = M[r4 + 12];
84200602:	89 c6       	rMAC = rMAC AND 0xffff;
84200604:	4b 46       	r1 = rMAC * 25 (int);

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200606:	11 90       	rMAC = MBS[r0 + 8];
84200608:	48 24       	Null = rMAC - 1;
8420060a:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_sample_rate_4;

8420060c <Lc_rtp_decode_opmsg_set_sample_rate_2>:
8420060c:	c8 24       	Null = rMAC - 3;
8420060e:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_sample_rate_4;

84200610 <Lc_rtp_decode_opmsg_set_sample_rate_3>:
    {
        return FALSE;
84200610:	02 00       	r0 = Null + Null;
84200612:	07 6e       	jump (m) Lc_rtp_decode_opmsg_set_sample_rate_5;

84200614 <Lc_rtp_decode_opmsg_set_sample_rate_4>:
    }

    opx_data->sample_rate = sample_rate;
84200614:	13 af       	M[r0 + 80] = r1;
    ttp_configure_rate(opx_data->ttp_instance, sample_rate);
84200616:	92 a8       	r0 = M[r0 + 72];
84200618:	ff fd c8 f0 	call (m) 0x1961a;
8420061c:	23 e0 

    return TRUE;
8420061e:	42 20       	r0 = Null + 1;

84200620 <Lc_rtp_decode_opmsg_set_sample_rate_5>:
}
84200620:	f1 48       	popm <FP, r4, rLink>;
84200622:	d8 4c       	rts;

84200624 <$_rtp_decode_opmsg_set_sp_adjustment>:

bool rtp_decode_opmsg_set_sp_adjustment(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200624:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200626:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200628:	ef fd ff ff 	call (m) 0x4e6;
8420062c:	3f e5 
8420062e:	17 00       	r5 = r0 + Null;

bool rtp_decode_opmsg_set_sp_adjustment(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200630:	39 90       	rMAC = MBS[r5 + 8];
84200632:	48 24       	Null = rMAC - 1;
84200634:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_sp_adjustment_4;

84200636 <Lc_rtp_decode_opmsg_set_sp_adjustment_2>:
84200636:	c8 24       	Null = rMAC - 3;
84200638:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_sp_adjustment_4;

8420063a <Lc_rtp_decode_opmsg_set_sp_adjustment_3>:
    {
        return FALSE;
8420063a:	02 00       	r0 = Null + Null;
8420063c:	08 6e       	jump (m) Lc_rtp_decode_opmsg_set_sp_adjustment_5;

8420063e <Lc_rtp_decode_opmsg_set_sp_adjustment_4>:
    }

    return ttp_configure_sp_adjustment( opx_data->ttp_instance,
                                        ttp_get_msg_sp_adjustment(message_data));
8420063e:	32 00       	r0 = r4 + Null;
84200640:	08 f0 35 e8 	call (m) $M.download_support_lib.ttp_get_msg_sp_adjustment.L_pb_mismatch;
84200644:	13 00       	r1 = r0 + Null;
84200646:	ba a8       	r0 = M[r5 + 72];
84200648:	08 f0 29 e5 	call (m) $_ttp_configure_sp_adjustment;

8420064c <Lc_rtp_decode_opmsg_set_sp_adjustment_5>:
}
8420064c:	f2 48       	popm <FP, r4, r5, rLink>;
8420064e:	d8 4c       	rts;

84200650 <$_rtp_decode_opmsg_adjust_ttp_timestamp>:


bool rtp_decode_opmsg_adjust_ttp_timestamp(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200650:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200652:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200654:	ef fd ff ff 	call (m) 0x4e6;
84200658:	33 e4 
8420065a:	17 00       	r5 = r0 + Null;

bool rtp_decode_opmsg_adjust_ttp_timestamp(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
8420065c:	39 90       	rMAC = MBS[r5 + 8];
8420065e:	48 24       	Null = rMAC - 1;
84200660:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_adjust_ttp_timestamp_4;

84200662 <Lc_rtp_decode_opmsg_adjust_ttp_timestamp_2>:
84200662:	c8 24       	Null = rMAC - 3;
84200664:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_adjust_ttp_timestamp_4;

84200666 <Lc_rtp_decode_opmsg_adjust_ttp_timestamp_3>:
    {
        return FALSE;
84200666:	02 00       	r0 = Null + Null;
84200668:	09 6e       	jump (m) Lc_rtp_decode_opmsg_adjust_ttp_timestamp_5;

8420066a <Lc_rtp_decode_opmsg_adjust_ttp_timestamp_4>:
    }

    ttp_adjust_ttp_timestamp( opx_data->ttp_instance,
                              ttp_get_msg_adjust_ttp_timestamp(message_data));
8420066a:	32 00       	r0 = r4 + Null;
8420066c:	08 f0 2d e7 	call (m) $_ttp_get_msg_adjust_ttp_timestamp;
84200670:	13 00       	r1 = r0 + Null;
84200672:	ba a8       	r0 = M[r5 + 72];
84200674:	08 f0 31 e4 	call (m) $_ttp_adjust_ttp_timestamp;

    return TRUE;
84200678:	42 20       	r0 = Null + 1;

8420067a <Lc_rtp_decode_opmsg_adjust_ttp_timestamp_5>:
}
8420067a:	f2 48       	popm <FP, r4, r5, rLink>;
8420067c:	d8 4c       	rts;

8420067e <$_rtp_decode_opmsg_set_buffer_size>:

bool rtp_decode_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420067e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200680:	17 00       	r5 = r0 + Null;
84200682:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200684:	ef fd ff ff 	call (m) 0x4e6;
84200688:	23 e3 
8420068a:	10 09       	r6 = r0 + Null;

bool rtp_decode_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if (opmgr_op_is_running(op_data))
8420068c:	3a 00       	r0 = r5 + Null;
8420068e:	ff fd 28 f0 	call (m) 0x5700;
84200692:	33 e3 
84200694:	10 04       	Null = r0 - Null;
84200696:	0d 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_buffer_size_5;

84200698 <Lc_rtp_decode_opmsg_set_buffer_size_2>:
    {
        L2_DBG_MSG("The RTP decode operator is running. Cannot set the buffer size");
84200698:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420069c:	88 24       	Null = rMAC - 2;
8420069e:	07 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_buffer_size_4;

842006a0 <Lc_rtp_decode_opmsg_set_buffer_size_3>:
842006a0:	55 f1 02 f0 	r0 = Null + 357564870;
842006a4:	c6 41 
842006a6:	ff fd 03 f0 	call (m) 0xccc;
842006aa:	27 e1 

842006ac <Lc_rtp_decode_opmsg_set_buffer_size_4>:
        return FALSE;
842006ac:	02 00       	r0 = Null + Null;
842006ae:	1b 6e       	jump (m) Lc_rtp_decode_opmsg_set_buffer_size_11;

842006b0 <Lc_rtp_decode_opmsg_set_buffer_size_5>:
    }

    if  (opx_data->op_buffer != NULL)
842006b0:	81 f0 0e 88 	rMAC = M[r6 + 56];
842006b4:	0c 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_buffer_size_8;

842006b6 <Lc_rtp_decode_opmsg_set_buffer_size_6>:
    {
        L2_DBG_MSG("rtp_decode_opmsg_set_buffer_size: Cannot set the buffer size for an operator with connected output!");
842006b6:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842006ba:	88 24       	Null = rMAC - 2;
842006bc:	f8 69       	if LT jump (m) Lc_rtp_decode_opmsg_set_buffer_size_4;

842006be <Lc_rtp_decode_opmsg_set_buffer_size_7>:
842006be:	55 f1 02 f0 	r0 = Null + 357564933;
842006c2:	05 42 
842006c4:	ff fd 03 f0 	call (m) 0xccc;
842006c8:	29 e0 
842006ca:	f1 6f       	jump (m) Lc_rtp_decode_opmsg_set_buffer_size_4;

842006cc <Lc_rtp_decode_opmsg_set_buffer_size_8>:
        return FALSE;
    }

    opx_data->latency_buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_BUFFER_SIZE, BUFFER_SIZE);
842006cc:	f1 88       	rMAC = M[r4 + 12];
842006ce:	89 c6       	rMAC = rMAC AND 0xffff;
842006d0:	81 f0 13 8e 	M[r6 + 76] = rMAC;

    if (opx_data->latency_buffer_size > RTP_DECODE_DEFAULT_BUFFER_SIZE)
842006d4:	10 f0 00 26 	Null = rMAC - 512;
842006d8:	09 f0 8b e0 	if LS jump (m) Lc_rtp_decode_opmsg_set_buffer_size_10;

842006dc <Lc_rtp_decode_opmsg_set_buffer_size_9>:
    {
        opx_data->kick_on_full_output = TRUE;
842006dc:	41 20       	rMAC = Null + 1;
842006de:	81 f0 19 8e 	M[r6 + 100] = rMAC;

842006e2 <Lc_rtp_decode_opmsg_set_buffer_size_10>:
    }

    return TRUE;
842006e2:	42 20       	r0 = Null + 1;

842006e4 <Lc_rtp_decode_opmsg_set_buffer_size_11>:
}
842006e4:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842006e6:	d8 4c       	rts;

842006e8 <$_rtp_decode_opmsg_set_latency_change_notification>:
    }
#endif
}

bool rtp_decode_opmsg_set_latency_change_notification(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842006e8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842006ea:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842006ec:	ef fd fe ff 	call (m) 0x4e6;
842006f0:	3b ef 
bool rtp_decode_opmsg_set_latency_change_notification(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    opx_data->latency_change_notify_enable = OPMSG_FIELD_GET(message_data,
                                             OPMSG_RTP_SET_LATENCY_CHANGE_NOTIFICATION, ENABLE_LATENCY_NOTIFY) & 1;
842006f2:	11 a2       	rMAC = MBU[r0 + 16];
842006f4:	f3 88       	r1 = M[r4 + 12];
842006f6:	11 ff fd 1f 	rMAC = rMAC AND 0xfffffffd;
842006fa:	1b c0       	r1 = r1 AND 0x1;
842006fc:	1b 54       	r1 = r1 LSHIFT 1;
842006fe:	c9 12       	rMAC = rMAC OR r1;
84200700:	11 aa       	MB[r0 + 16] = rMAC;

    return TRUE;
84200702:	42 20       	r0 = Null + 1;

84200704 <Lc_rtp_decode_opmsg_set_latency_change_notification_2>:
}
84200704:	f1 48       	popm <FP, r4, rLink>;
84200706:	d8 4c       	rts;

84200708 <$_rtp_decode_opmsg_set_ttp_notification>:


bool rtp_decode_opmsg_set_ttp_notification(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200708:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420070a:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420070c:	ef fd fe ff 	call (m) 0x4e6;
84200710:	3b ee 

bool rtp_decode_opmsg_set_ttp_notification(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if ((opx_data->mode != RTP_DECODE))
84200712:	11 90       	rMAC = MBS[r0 + 8];
84200714:	48 24       	Null = rMAC - 1;
84200716:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_notification_3;

84200718 <Lc_rtp_decode_opmsg_set_ttp_notification_2>:
    {
        return FALSE;
84200718:	02 00       	r0 = Null + Null;
8420071a:	05 6e       	jump (m) Lc_rtp_decode_opmsg_set_ttp_notification_4;

8420071c <Lc_rtp_decode_opmsg_set_ttp_notification_3>:
    }

    opx_data->ttp_notification_interval = OPMSG_FIELD_GET(message_data,
                                          OPMSG_RTP_SET_TTP_NOTIFICATION, INTERVAL_COUNT);
8420071c:	f1 88       	rMAC = M[r4 + 12];
8420071e:	89 c6       	rMAC = rMAC AND 0xffff;
84200720:	d1 bf       	M[r0 + 124] = rMAC;
    return TRUE;
84200722:	42 20       	r0 = Null + 1;

84200724 <Lc_rtp_decode_opmsg_set_ttp_notification_4>:
}
84200724:	f1 48       	popm <FP, r4, rLink>;
84200726:	d8 4c       	rts;

84200728 <$_rtp_decode_opmsg_resync_ttp>:

bool rtp_decode_opmsg_resync_ttp(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200728:	c8 1c       	pushm <FP(=SP), rLink>;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420072a:	ef fd fe ff 	call (m) 0x4e6;
8420072e:	3d ed 

bool rtp_decode_opmsg_resync_ttp(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200730:	11 90       	rMAC = MBS[r0 + 8];
84200732:	48 24       	Null = rMAC - 1;
84200734:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_resync_ttp_4;

84200736 <Lc_rtp_decode_opmsg_resync_ttp_2>:
84200736:	c8 24       	Null = rMAC - 3;
84200738:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_resync_ttp_4;

8420073a <Lc_rtp_decode_opmsg_resync_ttp_3>:
    {
        return FALSE;
8420073a:	02 00       	r0 = Null + Null;
8420073c:	06 6e       	jump (m) Lc_rtp_decode_opmsg_resync_ttp_5;

8420073e <Lc_rtp_decode_opmsg_resync_ttp_4>:
    }

    ttp_reset(opx_data->ttp_instance);
8420073e:	92 a8       	r0 = M[r0 + 72];
84200740:	ff fd c6 f0 	call (m) 0x19488;
84200744:	29 ea 
    return TRUE;
84200746:	42 20       	r0 = Null + 1;

84200748 <Lc_rtp_decode_opmsg_resync_ttp_5>:
}
84200748:	c8 48       	popm <FP, rLink>;
8420074a:	d8 4c       	rts;

8420074c <$_rtp_decode_process_data>:
    }
}


void rtp_decode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
8420074c:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
8420074e:	5e 4c       	SP = SP + 120;
84200750:	42 de       	M[FP + 32] = r0;
84200752:	4b de       	M[FP + 36] = r1;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200754:	ef fd fe ff 	call (m) 0x4e6;
84200758:	33 ec 
8420075a:	10 09       	r6 = r0 + Null;
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    unsigned packet_size;
    tCbuffer *clone_buffer;
    tCbuffer *buffer;
    tCbuffer *ip_buffer = opx_data->ip_buffer;
8420075c:	8a f0 0d 88 	r8 = M[r6 + 52];
    tCbuffer *op_buffer = opx_data->op_buffer;
84200760:	86 f0 0e 88 	r4 = M[r6 + 56];
    unsigned available_octets, available_space;
    unsigned rtp_header_size = RTP_MINIMUM_HEADER_SIZE +
                   (opx_data->scms_enable ? SCMS_HEADER_SIZE : 0);
84200764:	81 f0 10 82 	rMAC = MBU[r6 + 16];
84200768:	42 23       	r0 = Null + 13;
8420076a:	03 23       	r1 = Null + 12;
8420076c:	09 c0       	rMAC = rMAC AND 0x1;
8420076e:	01 f2 03 c0 	if NE r1 = r0 + Null;
84200772:	53 de       	M[FP + 40] = r1;
    metadata_tag* tag;

    patch_fn_shared(rtp_decode_process_data);

    if ((ip_buffer == NULL) || (op_buffer == NULL))
84200774:	0f fa 00 c2 	Null = r8 - Null;
84200778:	00 f0 9b e6 	if EQ jump (m) Lc_rtp_decode_process_data_58;

8420077c <Lc_rtp_decode_process_data_2>:
8420077c:	30 04       	Null = r4 - Null;
8420077e:	00 f0 95 e6 	if EQ jump (m) Lc_rtp_decode_process_data_58;

84200782 <Lc_rtp_decode_process_data_3>:
    {
        return;
    }

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84200782:	80 f0 1a 88 	Null = M[r6 + 104];
84200786:	08 60       	if EQ jump (m) Lc_rtp_decode_process_data_5;

84200788 <Lc_rtp_decode_process_data_4>:
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84200788:	81 f0 0f 88 	rMAC = M[r6 + 60];
8420078c:	59 de       	M[FP + 44] = rMAC;
        buffer = opx_data->u.pack.frame_buffer;
8420078e:	81 f0 10 88 	rMAC = M[r6 + 64];
84200792:	61 de       	M[FP + 48] = rMAC;
84200794:	05 6e       	jump (m) Lc_rtp_decode_process_data_6;

84200796 <Lc_rtp_decode_process_data_5>:
    }
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
84200796:	81 f0 0f 88 	rMAC = M[r6 + 60];
8420079a:	59 de       	M[FP + 44] = rMAC;
        buffer = opx_data->op_buffer;
8420079c:	66 de       	M[FP + 48] = r4;

8420079e <Lc_rtp_decode_process_data_6>:
     */
    /* TODO There could be an octet difference between _ex (used by a2dp endpoint)
     * and cbuffer (used by octet_buffer therefore by RTP) when asking for available data.
     * To avoid that difference use the buff_metadata_available_octets until RTP is not
     * convert to _ex buffer. NOTE  _ex buffer does not support unaligned copy yet.  */
    available_octets = buff_metadata_available_octets(ip_buffer);
8420079e:	52 08       	r0 = r8 + Null;
842007a0:	ff fd a0 f0 	call (m) 0x14958;
842007a4:	39 ed 
842007a6:	13 09       	r9 = r0 + Null;
    available_space = cbuffer_calc_amount_space_ex(op_buffer);
842007a8:	32 00       	r0 = r4 + Null;
842007aa:	ff fd e1 f1 	call (m) 0x3cb3e;
842007ae:	35 ec 

    L4_DBG_MSG2("RTP START available data (octets) = %d, available space (octets) = %d",
            cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));

    if (opx_data->kick_on_full_output && (available_octets > available_space))
842007b0:	80 f0 19 88 	Null = M[r6 + 100];
842007b4:	08 60       	if EQ jump (m) Lc_rtp_decode_process_data_9;

842007b6 <Lc_rtp_decode_process_data_7>:
842007b6:	2f fb 00 c2 	Null = r9 - r0;
842007ba:	09 f0 8b e0 	if LS jump (m) Lc_rtp_decode_process_data_9;

842007be <Lc_rtp_decode_process_data_8>:
    {
        /* Kick forwards to keep data flowing in case the next operator is a splitter */
        touched->sources = TOUCHED_SOURCE_0;
842007be:	41 20       	rMAC = Null + 1;
842007c0:	4b d8       	r1 = M[FP + 36];
842007c2:	19 ee       	M[r1 + Null] = rMAC;

842007c4 <Lc_rtp_decode_process_data_9>:
    }

    if(opx_data->mode == RTP_PASSTHROUGH)
842007c4:	81 f0 08 80 	rMAC = MBS[r6 + 8];
842007c8:	1e 62       	if NE jump (m) Lc_rtp_decode_process_data_14;

842007ca <Lc_rtp_decode_process_data_10>:
    {
        unsigned octets_copied = cbuffer_copy_ex(op_buffer, ip_buffer, available_octets);
842007ca:	5c 08       	r2 = r9 + Null;
842007cc:	53 08       	r1 = r8 + Null;
842007ce:	32 00       	r0 = r4 + Null;
842007d0:	ff fd 5e f1 	call (m) 0x2c4ec;
842007d4:	3d e8 

        /* copy as many data as possible to the output buffer.*/
        if (octets_copied > 0)
842007d6:	10 04       	Null = r0 - Null;
842007d8:	0a 60       	if EQ jump (m) Lc_rtp_decode_process_data_12;

842007da <Lc_rtp_decode_process_data_11>:
        {
            /* Propagate any metadata to the output.*/
            metadata_strict_transport(ip_buffer, op_buffer, octets_copied);
842007da:	14 00       	r2 = r0 + Null;
842007dc:	33 00       	r1 = r4 + Null;
842007de:	52 08       	r0 = r8 + Null;
842007e0:	ff fd a2 f0 	call (m) 0x14c88;
842007e4:	29 e5 
            touched->sources = TOUCHED_SOURCE_0;
842007e6:	41 20       	rMAC = Null + 1;
842007e8:	4a d8       	r0 = M[FP + 36];
842007ea:	11 ee       	M[r0 + Null] = rMAC;

842007ec <Lc_rtp_decode_process_data_12>:
        }

        if (cbuffer_calc_amount_data_ex(ip_buffer) == 0)
842007ec:	52 08       	r0 = r8 + Null;
842007ee:	ff fd e1 f1 	call (m) 0x3cad6;
842007f2:	29 e7 
842007f4:	10 04       	Null = r0 - Null;
842007f6:	01 f0 9d e5 	if NE jump (m) Lc_rtp_decode_process_data_58;

842007fa <Lc_rtp_decode_process_data_13>:
    }

    /*
     * Consumed all the available data -> kick backwards.
     */
    touched->sinks = TOUCHED_SINK_0;
842007fa:	41 20       	rMAC = Null + 1;
842007fc:	4a d8       	r0 = M[FP + 36];
842007fe:	51 8e       	M[r0 + 4] = rMAC;
84200800:	0f f0 93 e5 	jump (m) Lc_rtp_decode_process_data_58;

84200804 <Lc_rtp_decode_process_data_14>:
        {
            touched->sinks = TOUCHED_SINK_0;
        }
        return;
    }
    else if ((opx_data->mode == RTP_TTP_ONLY) && (opx_data->codec_type == APTX))
84200804:	c8 24       	Null = rMAC - 3;
84200806:	31 62       	if NE jump (m) Lc_rtp_decode_process_data_24;

84200808 <Lc_rtp_decode_process_data_15>:
84200808:	81 f0 11 80 	rMAC = MBS[r6 + 17];
8420080c:	2e 62       	if NE jump (m) Lc_rtp_decode_process_data_24;

8420080e <Lc_rtp_decode_process_data_16>:
    {

        unsigned octets_copied = MIN(available_octets, available_space);
8420080e:	2f fb 00 c2 	Null = r9 - r0;
84200812:	02 f0 89 e0 	if C jump (m) Lc_rtp_decode_process_data_18;

84200816 <Lc_rtp_decode_process_data_17>:
84200816:	5a 08       	r0 = r9 + Null;
84200818:	01 6e       	jump (m) Lc_rtp_decode_process_data_18;

8420081a <Lc_rtp_decode_process_data_18>:
         * actually exists. It can only ever process 4 octets at a time,
         * so rounding down here should always be safe
         */
        octets_copied &= ~1;

        if (octets_copied > 0)
8420081a:	27 ff fe 1f 	r5 = r0 AND 0xfffffffe;
8420081e:	1d 60       	if EQ jump (m) Lc_rtp_decode_process_data_23;

84200820 <Lc_rtp_decode_process_data_20>:
        {
            metadata_transport_with_ttp(opx_data, octets_copied);
84200820:	3b 00       	r1 = r5 + Null;
84200822:	42 08       	r0 = r6 + Null;
84200824:	04 f0 2d e9 	call (m) Lc_metadata_transport_with_ttp_1;
            if (opx_data->pack_latency_buffer)
84200828:	80 f0 1a 88 	Null = M[r6 + 104];
8420082c:	0d 60       	if EQ jump (m) Lc_rtp_decode_process_data_22;

8420082e <Lc_rtp_decode_process_data_21>:
            {
                /* Pack to internal buffer. */
                cbuffer_copy_ex(opx_data->u.pack.internal_buffer, ip_buffer, octets_copied);
8420082e:	82 f0 11 88 	r0 = M[r6 + 68];
84200832:	3c 00       	r2 = r5 + Null;
84200834:	53 08       	r1 = r8 + Null;
84200836:	ff fd 5e f1 	call (m) 0x2c4ec;
8420083a:	37 e5 
                /* Copy as much as possible to the output. */
                rtp_decode_empty_internal_buffers(opx_data,touched);
8420083c:	42 08       	r0 = r6 + Null;
8420083e:	4b d8       	r1 = M[FP + 36];
84200840:	05 f0 29 e0 	call (m) Lc_rtp_decode_empty_internal_buffers_1;
84200844:	0a 6e       	jump (m) Lc_rtp_decode_process_data_23;

84200846 <Lc_rtp_decode_process_data_22>:
            }
            else
            {
                /* Copy to output. */
                cbuffer_copy_ex(op_buffer, ip_buffer, octets_copied);
84200846:	3c 00       	r2 = r5 + Null;
84200848:	53 08       	r1 = r8 + Null;
8420084a:	32 00       	r0 = r4 + Null;
8420084c:	ff fd 5e f1 	call (m) 0x2c4ec;
84200850:	21 e5 
                touched->sources = TOUCHED_SOURCE_0;
84200852:	41 20       	rMAC = Null + 1;
84200854:	4a d8       	r0 = M[FP + 36];
84200856:	11 ee       	M[r0 + Null] = rMAC;

84200858 <Lc_rtp_decode_process_data_23>:
            }
        }

        /* Kick back if less than one whole word in the input buffer */
        if (cbuffer_calc_amount_data_ex(ip_buffer) < 2)
84200858:	52 08       	r0 = r8 + Null;
8420085a:	ff fd e1 f1 	call (m) 0x3cad6;
8420085e:	3d e3 
84200860:	90 24       	Null = r0 - 2;
84200862:	cc 65       	if NC jump (m) Lc_rtp_decode_process_data_13;

84200864 <Lc__ite_14>:
84200864:	0f f0 af e4 	jump (m) Lc_rtp_decode_process_data_58;

84200868 <Lc_rtp_decode_process_data_24>:
        }
        return;
    }

    /* Get the next from the input buffer.*/
    tag = buff_metadata_peek(ip_buffer);
84200868:	52 08       	r0 = r8 + Null;
8420086a:	ff fd a0 f0 	call (m) 0x14920;
8420086e:	37 e5 
84200870:	16 00       	r4 = r0 + Null;
    packet_size = get_tag_size (tag);
84200872:	02 f0 37 e5 	call (m) Lc_get_tag_size_1;
84200876:	11 09       	r7 = r0 + Null;

    /* Empty the internal buffers to create some space. */
    rtp_decode_empty_internal_buffers(opx_data,touched);
84200878:	42 08       	r0 = r6 + Null;
8420087a:	4b d8       	r1 = M[FP + 36];
8420087c:	04 f0 2d ee 	call (m) Lc_rtp_decode_empty_internal_buffers_1;
84200880:	41 20       	rMAC = Null + 1;
84200882:	69 de       	M[FP + 52] = rMAC;
84200884:	4b 6e       	jump (m) Lc_rtp_decode_process_data_34;

84200886 <Lc_rtp_decode_process_data_25>:
                        (opx_data->sample_rate/2)) / opx_data->sample_rate);
                }
#endif
                else
                {
                    cbuffer_advance_read_ptr_ex(ip_buffer, header_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH);
84200886:	33 25       	r1 = r4 - 4;
84200888:	52 08       	r0 = r8 + Null;
8420088a:	ff fd e2 f1 	call (m) 0x3ccc0;
8420088e:	37 e1 

84200890 <Lc_rtp_decode_process_data_26>:
                }

                /* Copy the payload without the padding to the clone buffer. There the
                 * decoded frame is analysed to see how many sample is in it.  */
                cbuffer_copy_ex(clone_buffer, ip_buffer, payload_size);
84200890:	3c 00       	r2 = r5 + Null;
84200892:	53 08       	r1 = r8 + Null;
84200894:	5a d8       	r0 = M[FP + 44];
84200896:	ff fd 5e f1 	call (m) 0x2c4ec;
8420089a:	37 e2 

                /* Partially decode the frame to get a robust sample count determination
                 * for the time to play. */
                get_samples_in_packet(opx_data, &frame_data);
8420089c:	03 15       	r1 = FP + 80;
8420089e:	42 08       	r0 = r6 + Null;
842008a0:	04 f0 3f ef 	call (m) $_get_samples_in_packet;

                if(opx_data->mode == RTP_STRIP)
842008a4:	81 f0 08 80 	rMAC = MBS[r6 + 8];
842008a8:	88 24       	Null = rMAC - 2;
842008aa:	e7 62       	if NE jump (m) Lc_rtp_decode_process_data_55;

842008ac <Lc_rtp_decode_process_data_27>:
                {
                    /* Make the data available in the frame buffer. */
                    cbuffer_advance_write_ptr_ex(buffer, payload_size);
842008ac:	3b 00       	r1 = r5 + Null;
842008ae:	62 d8       	r0 = M[FP + 48];
842008b0:	ff fd e1 f1 	call (m) 0x3cc46;
842008b4:	37 ec 
                    /* Remove all the encoded data from the clone buffer. */
                    cbuffer_advance_read_ptr(clone_buffer, payload_size);
842008b6:	3b 00       	r1 = r5 + Null;
842008b8:	5a d8       	r0 = M[FP + 44];
842008ba:	ff fd ca f1 	call (m) 0x39de2;
842008be:	29 e9 
                    /* Delete the tag as it is not used any more.  */
                    delete_consumed_metadata_tag(ip_buffer, packet_size);
842008c0:	4b 08       	r1 = r7 + Null;
842008c2:	52 08       	r0 = r8 + Null;
842008c4:	02 f0 31 e3 	call (m) Lc_delete_consumed_metadata_tag_1;
                    /* Update the metadata in the output buffer.*/
                    buff_metadata_append(buffer, NULL, payload_size, 0);
842008c8:	05 00       	r3 = Null + Null;
842008ca:	03 00       	r1 = Null + Null;
842008cc:	3c 00       	r2 = r5 + Null;
842008ce:	62 d8       	r0 = M[FP + 48];
842008d0:	ff fd 9f f0 	call (m) 0x147b8;
842008d4:	29 e7 

842008d6 <Lc_rtp_decode_process_data_28>:
                    /* Kick forward. */
                    touched->sources = TOUCHED_SOURCE_0;
842008d6:	6a d8       	r0 = M[FP + 52];
842008d8:	49 d8       	rMAC = M[FP + 36];
842008da:	0a ee       	M[rMAC + Null] = r0;

842008dc <Lc_rtp_decode_process_data_29>:
                        /* Kick forward if there was any valid frames in the RTP packet. */
                        touched->sources = TOUCHED_SOURCE_0;
                    }
                }

                opx_data->rtp_decode_packet_count++;
842008dc:	81 f0 1d 88 	rMAC = M[r6 + 116];
842008e0:	49 20       	rMAC = rMAC + 1;
842008e2:	81 f0 1d 8e 	M[r6 + 116] = rMAC;

                /*
                 * notify ttp information if requested. ttp_notification interval is allowed to set
                 * only for RTP_DECODE mode
                 */
                if(opx_data->ttp_notification_interval > 0)
842008e6:	80 f0 1f 88 	Null = M[r6 + 124];
842008ea:	04 60       	if EQ jump (m) Lc_rtp_decode_process_data_31;

842008ec <Lc_rtp_decode_process_data_30>:
                {
                    rtp_notify_ttp(op_data,&frame_data);
842008ec:	03 15       	r1 = FP + 80;
842008ee:	42 d8       	r0 = M[FP + 32];
842008f0:	f0 4e       	call (m) Lc_rtp_notify_ttp_1;

842008f2 <Lc_rtp_decode_process_data_31>:
                }

                /* discard any padding */
                if (padding_amount != 0)
842008f2:	73 d8       	r1 = M[FP + 56];
842008f4:	05 60       	if EQ jump (m) Lc_rtp_decode_process_data_33;

842008f6 <Lc_rtp_decode_process_data_32>:
                {
                    cbuffer_advance_read_ptr_ex(ip_buffer, padding_amount);
842008f6:	52 08       	r0 = r8 + Null;
842008f8:	ff fd e1 f1 	call (m) 0x3ccc0;
842008fc:	29 ee 

842008fe <Lc_rtp_decode_process_data_33>:
                }

            }
        }
        available_octets -= packet_size;
842008fe:	00 f9 3b c2 	r9 = r9 - r7;

        /* unpack to output if possible. */
        rtp_decode_empty_internal_buffers(opx_data,touched);
84200902:	42 08       	r0 = r6 + Null;
84200904:	4b d8       	r1 = M[FP + 36];
84200906:	04 f0 23 ea 	call (m) Lc_rtp_decode_empty_internal_buffers_1;

        /* Read the next packet tag. */
        tag = buff_metadata_peek(ip_buffer);
8420090a:	52 08       	r0 = r8 + Null;
8420090c:	ff fd a0 f0 	call (m) 0x14920;
84200910:	35 e0 
84200912:	16 00       	r4 = r0 + Null;
        packet_size = get_tag_size (tag);
84200914:	02 f0 35 e0 	call (m) Lc_get_tag_size_1;
84200918:	11 09       	r7 = r0 + Null;

8420091a <Lc_rtp_decode_process_data_34>:
    packet_size = get_tag_size (tag);

    /* Empty the internal buffers to create some space. */
    rtp_decode_empty_internal_buffers(opx_data,touched);

    while ( (packet_size != 0) && (available_octets >= packet_size))
8420091a:	0f f9 00 c2 	Null = r7 - Null;
8420091e:	6e 61       	if EQ jump (m) Lc_rtp_decode_process_data_13;

84200920 <Lc_rtp_decode_process_data_35>:
84200920:	9f fb 00 c2 	Null = r9 - r7;
84200924:	6b 65       	if NC jump (m) Lc_rtp_decode_process_data_13;

84200926 <Lc_rtp_decode_process_data_36>:
    {
        if(!tag_valid(tag, opx_data))
84200926:	43 08       	r1 = r6 + Null;
84200928:	32 00       	r0 = r4 + Null;
8420092a:	01 f0 35 ec 	call (m) Lc_tag_valid_1;
8420092e:	10 04       	Null = r0 - Null;
84200930:	b1 60       	if EQ jump (m) Lc_rtp_decode_process_data_58;

84200932 <Lc_rtp_decode_process_data_37>:
        }
        /* Is there space in the sink for the unpacked data?
         * this needs to be a quick check and hence don't worry
         * about calculating the header size which isn't copied.
         */
        if ((cbuffer_calc_amount_space_ex(clone_buffer) - 4 ) < packet_size)
84200932:	5a d8       	r0 = M[FP + 44];
84200934:	ff fd e1 f1 	call (m) 0x3cb3e;
84200938:	2b e0 
8420093a:	11 25       	rMAC = r0 - 4;
8420093c:	9f f1 00 c2 	Null = rMAC - r7;
84200940:	a9 64       	if NC jump (m) Lc_rtp_decode_process_data_58;

84200942 <Lc_rtp_decode_process_data_38>:
                    cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));
            return;
        }

        if (packet_size < (rtp_header_size +
                opx_data->payload_header_size))
84200942:	81 f0 08 88 	rMAC = M[r6 + 32];
84200946:	52 d8       	r0 = M[FP + 40];
84200948:	51 00       	rMAC = r0 + rMAC;
8420094a:	1f f9 00 c2 	Null = r7 - rMAC;
8420094e:	02 f0 99 e0 	if C jump (m) Lc_rtp_decode_process_data_40;

84200952 <Lc_rtp_decode_process_data_39>:
        {
            /* packet is too small to contain header so discard it.*/
            cbuffer_advance_read_ptr_ex(ip_buffer, packet_size);
84200952:	4b 08       	r1 = r7 + Null;
84200954:	52 08       	r0 = r8 + Null;
84200956:	ff fd e1 f1 	call (m) 0x3ccc0;
8420095a:	2b eb 
            delete_consumed_metadata_tag(ip_buffer, packet_size);
8420095c:	4b 08       	r1 = r7 + Null;
8420095e:	52 08       	r0 = r8 + Null;
84200960:	01 f0 35 ee 	call (m) Lc_delete_consumed_metadata_tag_1;
84200964:	cd 6f       	jump (m) Lc_rtp_decode_process_data_33;

84200966 <Lc_rtp_decode_process_data_40>:
        }
        else
        {
            unsigned int fixed_header_first_part[RTP_FIXED_HEADER_FIRST_PART_LENGTH];
            /* read in first few bytes of RTP header */
            unpack_cbuff_to_array((int*)fixed_header_first_part, ip_buffer, RTP_FIXED_HEADER_FIRST_PART_LENGTH);
84200966:	04 21       	r2 = Null + 4;
84200968:	02 14       	r0 = FP + 64;
8420096a:	53 08       	r1 = r8 + Null;
8420096c:	05 f0 27 e7 	call (m) $_unpack_cbuff_to_array;

            /* validate version */
            if ((fixed_header_first_part[0] & RTP0_VERSION_MASK) != RTP0_VERSION_2)
84200970:	81 d8       	rMAC = M[FP + 64];
84200972:	12 f0 c0 00 	r0 = rMAC AND 0xc0;
84200976:	20 f0 80 24 	Null = r0 - 128;
8420097a:	11 60       	if EQ jump (m) Lc_rtp_decode_process_data_42;

8420097c <Lc_rtp_decode_process_data_41>:
            {
                /* Unsupported version - discard */
                cbuffer_advance_read_ptr_ex(ip_buffer, packet_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH);
8420097c:	93 f0 04 24 	r1 = r7 - 4;
84200980:	52 08       	r0 = r8 + Null;
84200982:	ff fd e1 f1 	call (m) 0x3ccc0;
84200986:	3f e9 
                delete_consumed_metadata_tag(ip_buffer, packet_size);
84200988:	4b 08       	r1 = r7 + Null;
8420098a:	52 08       	r0 = r8 + Null;
8420098c:	01 f0 29 ed 	call (m) Lc_delete_consumed_metadata_tag_1;
#ifdef DEBUG_RTP_DECODE
                /* Increment decode lost */
                opx_data->rtp_decode_lost++;
84200990:	81 f0 0a 88 	rMAC = M[r6 + 40];
84200994:	49 20       	rMAC = rMAC + 1;
84200996:	81 f0 0a 8e 	M[r6 + 40] = rMAC;
8420099a:	b2 6f       	jump (m) Lc_rtp_decode_process_data_33;

8420099c <Lc_rtp_decode_process_data_42>:
#endif
            }
            else
            {
                unsigned csrc_count = (fixed_header_first_part[0] & RTP0_CSRC_COUNT_MASK);
8420099c:	8e c1       	r4 = rMAC AND 0xf;
                unsigned seq = fixed_header_first_part[3] | (fixed_header_first_part[2]<<8);
8420099e:	92 d8       	r0 = M[FP + 72];
842009a0:	99 d8       	rMAC = M[FP + 76];
842009a2:	d2 55       	r0 = r0 LSHIFT 8;
842009a4:	57 12       	r5 = r0 OR rMAC;
                unsigned padding_amount = 0;
842009a6:	70 de       	M[FP + 56] = Null;
                unsigned header_size;
                unsigned payload_size;
                RTP_FRAME_DECODE_DATA frame_data = {FALSE, 0, 0, 0, 0, 0, 0, NULL};
842009a8:	07 f0 03 f0 	r1 = Null + 7340280;
842009ac:	f8 40 
842009ae:	02 15       	r0 = FP + 80;
842009b0:	c4 21       	r2 = Null + 7;
842009b2:	ff fd cc f0 	call (m) 0x1a1ee;
842009b6:	3d e1 
                uint16 frame_lengths[SBC_MAX_FRAMES] = {0, 0, 0, 0, 0,
                                                        0, 0, 0, 0, 0,
                                                        0, 0, 0, 0, 0};
842009b8:	07 f0 03 f0 	r1 = Null + 7340308;
842009bc:	14 41 
842009be:	c2 16       	r0 = FP + 108;
842009c0:	84 2b       	r2 = Null + 30;
842009c2:	ff fd cc f0 	call (m) 0x1a2ca;
842009c6:	29 e8 
                /* Set the frame header decode structure to remove gcc warnings. */

                /* check the sequence number unless local value is 0 which
                 * means initialisation. */
                if ((opx_data->sequence_number != 0) &&
                    (seq != (opx_data->sequence_number + 1)))
842009c8:	81 f0 03 88 	rMAC = M[r6 + 12];
842009cc:	0b 60       	if EQ jump (m) Lc_rtp_decode_process_data_45;

842009ce <Lc_rtp_decode_process_data_43>:
842009ce:	4a 20       	r0 = rMAC + 1;
842009d0:	b8 04       	Null = r5 - r0;
842009d2:	08 60       	if EQ jump (m) Lc_rtp_decode_process_data_45;

842009d4 <Lc_rtp_decode_process_data_44>:
                {
#ifdef DEBUG_RTP_DECODE
                    opx_data->rtp_decode_late += seq - (opx_data->sequence_number + 1);
842009d4:	82 f0 09 88 	r0 = M[r6 + 36];
842009d8:	ba 00       	r0 = r5 + r0;
842009da:	52 24       	r0 = r0 - 1;
842009dc:	51 04       	rMAC = r0 - rMAC;
842009de:	81 f0 09 8e 	M[r6 + 36] = rMAC;

842009e2 <Lc_rtp_decode_process_data_45>:
                    /* TODO - insert dummy frame when data is lost? (TODO This is an old comment) */
#endif
                }

                /* update sequence number */
                opx_data->sequence_number = seq;
842009e2:	87 f0 03 8e 	M[r6 + 12] = r5;

                /* Calculate the header size */
                header_size = rtp_header_size + (csrc_count * 4) +
                             opx_data->payload_header_size;
842009e6:	72 54       	r0 = r4 LSHIFT 2;
842009e8:	81 f0 08 88 	rMAC = M[r6 + 32];
842009ec:	51 00       	rMAC = r0 + rMAC;
842009ee:	52 d8       	r0 = M[FP + 40];
842009f0:	8e 00       	r4 = rMAC + r0;

                if ((fixed_header_first_part[0] & RTP0_PADDING) != 0)
842009f2:	81 d8       	rMAC = M[FP + 64];
842009f4:	49 c2       	rMAC = rMAC AND 0x20;
842009f6:	0f 60       	if EQ jump (m) Lc_rtp_decode_process_data_48;

842009f8 <Lc_rtp_decode_process_data_46>:
                {
                    /* padding amount is the last byte in the buffer. The first part
                     * of the header is already read. The current read offset is
                     * RTP_FIXED_HEADER_FIRST_PART_LENGTH. */
                    unpack_cbuff_to_array_from_offset((int*) &padding_amount, ip_buffer,
                            packet_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH - 1, 1);
842009f8:	45 20       	r3 = Null + 1;
842009fa:	94 f3 fb 3b 	r2 = r7 + -5;
842009fe:	82 13       	r0 = FP + 56;
84200a00:	53 08       	r1 = r8 + Null;
84200a02:	05 f0 37 e4 	call (m) $_unpack_cbuff_to_array_from_offset;

                    /* ignore rogue values  */
                    if (padding_amount > (packet_size - header_size))
84200a06:	71 d8       	rMAC = M[FP + 56];
84200a08:	6f f9 02 c2 	r0 = r7 - r4;
84200a0c:	88 04       	Null = rMAC - r0;
84200a0e:	09 f0 87 e0 	if LS jump (m) Lc_rtp_decode_process_data_48;

84200a12 <Lc_rtp_decode_process_data_47>:
                    {
                        padding_amount = 0;
84200a12:	70 de       	M[FP + 56] = Null;

84200a14 <Lc_rtp_decode_process_data_48>:
                    }
                }

                /* calc size of the frame that needs to be written to DSP  */
                payload_size = packet_size - header_size - padding_amount;
84200a14:	6f f9 01 c2 	rMAC = r7 - r4;
84200a18:	72 d8       	r0 = M[FP + 56];
84200a1a:	8f 04       	r5 = rMAC - r0;

                patch_fn_shared(rtp_decode_process_data);

                if (opx_data->codec_type == SBC)
84200a1c:	81 f0 11 80 	rMAC = MBS[r6 + 17];
84200a20:	48 24       	Null = rMAC - 1;
84200a22:	0f 62       	if NE jump (m) Lc_rtp_decode_process_data_50;

84200a24 <Lc_rtp_decode_process_data_49>:
                    /* ip_buffer read pointer has already advanced to
                     * FIXED_HEADER_TIMESTAMP and header_size includes
                     * opx_data->payload_header_size */
                    unpack_cbuff_to_array_from_offset(&rtp_sbc_header, ip_buffer,
                                 header_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH -
                                 opx_data->payload_header_size, 1);
84200a24:	45 20       	r3 = Null + 1;
84200a26:	31 25       	rMAC = r4 - 4;
84200a28:	82 f0 08 88 	r0 = M[r6 + 32];
84200a2c:	8c 04       	r2 = rMAC - r0;
84200a2e:	c2 13       	r0 = FP + 60;
84200a30:	53 08       	r1 = r8 + Null;
84200a32:	05 f0 27 e3 	call (m) $_unpack_cbuff_to_array_from_offset;
                    frame_data.nr_of_frames_rtp_header = rtp_sbc_header & SBC_HEADER_SIZE_MASK;
84200a36:	79 d8       	rMAC = M[FP + 60];
84200a38:	89 c1       	rMAC = rMAC AND 0xf;
84200a3a:	91 dd       	MH[FP + 100] = rMAC;
                    frame_data.frame_length_extra = (uint16 *)&frame_lengths;
84200a3c:	c1 16       	rMAC = FP + 108;
84200a3e:	d1 de       	M[FP + 104] = rMAC;

84200a40 <Lc_rtp_decode_process_data_50>:
                }

                /* The RTP timestamp field is actually a sample count which is
                 * only reliable for APTX adaptive. For other decoders the header is discarded. */
                if (opx_data->mode == RTP_DECODE && opx_data->codec_type == APTXADAPTIVE)
84200a40:	81 f0 08 80 	rMAC = MBS[r6 + 8];
84200a44:	48 24       	Null = rMAC - 1;
84200a46:	20 63       	if NE jump (m) Lc_rtp_decode_process_data_25;

84200a48 <Lc_rtp_decode_process_data_51>:
84200a48:	81 f0 11 80 	rMAC = MBS[r6 + 17];
84200a4c:	88 25       	Null = rMAC - 6;
84200a4e:	1c 63       	if NE jump (m) Lc_rtp_decode_process_data_25;

84200a50 <Lc_rtp_decode_process_data_52>:
                {
                    rtp_header_decode(opx_data, header_size, &rtp_header);
84200a50:	c4 18       	r2 = FP + 140;
84200a52:	33 00       	r1 = r4 + Null;
84200a54:	42 08       	r0 = r6 + Null;
84200a56:	7e 4e       	call (m) Lc_rtp_header_decode_1;
                    frame_data.rtp_timestamp = rtp_header.timestamp;
84200a58:	22 d9       	r0 = M[FP + 144];
84200a5a:	c2 de       	M[FP + 96] = r0;
                    TIME_INTERVAL ttp_adj = RTP_TIMESTAMP_APTX_AD_GET_TTP_ADJ(rtp_header.timestamp);
84200a5c:	92 52       	r0 = r0 LSHIFT -16;
84200a5e:	14 0c       	r2 = SE16 r0;

                    if (rtp_header.source != opx_data->prev_src_id || opx_data->rtp_ttp_adjust != ttp_adj)
84200a60:	2b d9       	r1 = M[FP + 148];
84200a62:	81 f0 1c 88 	rMAC = M[r6 + 112];
84200a66:	58 04       	Null = r1 - rMAC;
84200a68:	05 62       	if NE jump (m) Lc_rtp_decode_process_data_54;

84200a6a <Lc_rtp_decode_process_data_53>:
84200a6a:	81 f0 20 88 	rMAC = M[r6 + 128];
84200a6e:	08 05       	Null = rMAC - r2;
84200a70:	10 61       	if EQ jump (m) Lc_rtp_decode_process_data_26;

84200a72 <Lc_rtp_decode_process_data_54>:
                    {
                        rtp_source_changed(op_data, rtp_header.source, ttp_adj );
84200a72:	42 d8       	r0 = M[FP + 32];
84200a74:	ab 4e       	call (m) Lc_rtp_source_changed_1;
84200a76:	0d 6f       	jump (m) Lc_rtp_decode_process_data_26;

84200a78 <Lc_rtp_decode_process_data_55>:
                    /* Update the metadata in the output buffer.*/
                    buff_metadata_append(buffer, NULL, payload_size, 0);
                    /* Kick forward. */
                    touched->sources = TOUCHED_SOURCE_0;
                }
                else if (opx_data->mode == RTP_DECODE)
84200a78:	48 24       	Null = rMAC - 1;
84200a7a:	31 63       	if NE jump (m) Lc_rtp_decode_process_data_29;

84200a7c <Lc_rtp_decode_process_data_56>:
                {
                    /* Timestamp and transport the tag. */
                    transport_metadata_tag(opx_data, &frame_data, packet_size);
84200a7c:	03 15       	r1 = FP + 80;
84200a7e:	4c 08       	r2 = r7 + Null;
84200a80:	42 08       	r0 = r6 + Null;
84200a82:	01 f0 25 e9 	call (m) Lc_transport_metadata_tag_1;
                    if ((frame_data.nr_of_frames > 0)&&(!opx_data->pack_latency_buffer))
84200a86:	b8 d8       	Null = M[FP + 92];
84200a88:	2a 61       	if EQ jump (m) Lc_rtp_decode_process_data_29;

84200a8a <Lc_rtp_decode_process_data_57>:
84200a8a:	80 f0 1a 88 	Null = M[r6 + 104];
84200a8e:	27 63       	if NE jump (m) Lc_rtp_decode_process_data_29;

84200a90 <Lc__ite_15>:
84200a90:	23 6f       	jump (m) Lc_rtp_decode_process_data_28;

84200a92 <Lc_rtp_decode_process_data_58>:
     */
    touched->sinks = TOUCHED_SINK_0;

    L4_DBG_MSG2("RTP END available data (octets) = %d, available space (octets) = %d",
            cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));
}
84200a92:	62 4c       	SP = SP + -120;
84200a94:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200a96:	d8 4c       	rts;

84200a98 <Lc_rtp_set_payload_header_size_1>:
 * potentially other parameters in the future) will be set according to the codec type.
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
84200a98:	c8 1c       	pushm <FP(=SP), rLink>;
    switch (opx_data->codec_type)
84200a9a:	51 a0       	rMAC = MBS[r0 + 17];
84200a9c:	11 60       	if EQ jump (m) Lc_rtp_set_payload_header_size_9;

84200a9e <Lc_rtp_set_payload_header_size_2>:
84200a9e:	08 24       	Null = rMAC - 0;
84200aa0:	11 6c       	if LE jump (m) Lc_rtp_set_payload_header_size_10;

84200aa2 <Lc_rtp_set_payload_header_size_3>:
84200aa2:	88 24       	Null = rMAC - 2;
84200aa4:	04 6a       	if GT jump (m) Lc_rtp_set_payload_header_size_5;

84200aa6 <Lc_rtp_set_payload_header_size_4>:
    {
        case SBC:
        {
            opx_data->payload_header_size = SBC_PAYLOAD_HEADER_SIZE;
84200aa6:	41 20       	rMAC = Null + 1;
84200aa8:	11 9e       	M[r0 + 32] = rMAC;
84200aaa:	11 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

84200aac <Lc_rtp_set_payload_header_size_5>:
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
    switch (opx_data->codec_type)
84200aac:	c8 24       	Null = rMAC - 3;
84200aae:	04 62       	if NE jump (m) Lc_rtp_set_payload_header_size_7;

84200ab0 <Lc_rtp_set_payload_header_size_6>:
            opx_data->payload_header_size = ATRAC_PAYLOAD_HEADER_SIZE;
            break;
        }
        case MP3:
        {
            opx_data->payload_header_size = MP3_PAYLOAD_HEADER_SIZE;
84200ab0:	01 21       	rMAC = Null + 4;
84200ab2:	11 9e       	M[r0 + 32] = rMAC;
            break;
84200ab4:	0c 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

84200ab6 <Lc_rtp_set_payload_header_size_7>:
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
    switch (opx_data->codec_type)
84200ab6:	08 25       	Null = rMAC - 4;
84200ab8:	05 68       	if LT jump (m) Lc_rtp_set_payload_header_size_10;

84200aba <Lc_rtp_set_payload_header_size_8>:
84200aba:	88 25       	Null = rMAC - 6;
84200abc:	03 6a       	if GT jump (m) Lc_rtp_set_payload_header_size_10;

84200abe <Lc_rtp_set_payload_header_size_9>:
            opx_data->payload_header_size = MP3_PAYLOAD_HEADER_SIZE;
            break;
        }
        case APTX:
        {
            opx_data->payload_header_size = APTX_PAYLOAD_HEADER_SIZE;
84200abe:	10 9e       	M[r0 + 32] = Null;
84200ac0:	06 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

84200ac2 <Lc_rtp_set_payload_header_size_10>:
            break;
        }
        default:
        {
            /*mode not supported yet*/
            panic(PANIC_AUDIO_RTP_UNSUPPORTED_CODEC);
84200ac2:	02 f0 7a 40 	r0 = Null + 122;
84200ac6:	ff fd b2 f0 	call (m) 0x16fe6;
84200aca:	21 e9 

84200acc <Lc_rtp_set_payload_header_size_11>:
            break;
        }
    }

}
84200acc:	c8 48       	popm <FP, rLink>;
84200ace:	d8 4c       	rts;

84200ad0 <Lc_rtp_notify_ttp_1>:
 * Send ttp notification message
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_notify_ttp(OPERATOR_DATA *op_data, RTP_FRAME_DECODE_DATA *frame_data)
{
84200ad0:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200ad2:	50 4c       	SP = SP + 64;
84200ad4:	10 09       	r6 = r0 + Null;
84200ad6:	1f 00       	r5 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200ad8:	ef fd fd ff 	call (m) 0x4e6;
84200adc:	2f e0 
84200ade:	16 00       	r4 = r0 + Null;
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned ttp_notify_msg[OPMSG_REPLY_TTP_SEQ_WORD_SIZE];
    ttp_state_params state_params;
    unsigned ttp_resync_count;

    if ((frame_data->valid == FALSE) || (frame_data->nr_of_frames == 0))
84200ae0:	38 e8       	Null = M[r5 + Null];
84200ae2:	35 60       	if EQ jump (m) Lc_rtp_notify_ttp_5;

84200ae4 <Lc_rtp_notify_ttp_2>:
84200ae4:	f8 88       	Null = M[r5 + 12];
84200ae6:	33 60       	if EQ jump (m) Lc_rtp_notify_ttp_5;

84200ae8 <Lc_rtp_notify_ttp_3>:
    {
        /* Invalid frame */
        return;
    }

    opx_data->rtp_decode_valid_packet_count++;
84200ae8:	b1 b9       	rMAC = M[r4 + 120];
84200aea:	4a 20       	r0 = rMAC + 1;
84200aec:	b2 bf       	M[r4 + 120] = r0;

    /* ttp_notifictaion_interval is not 0 on reaching here */
    if( opx_data->rtp_decode_valid_packet_count % opx_data->ttp_notification_interval != 0)
84200aee:	f3 b9       	r1 = M[r4 + 124];
84200af0:	ff fd cb f0 	call (m) 0x1a2ae;
84200af4:	3f ed 
84200af6:	10 04       	Null = r0 - Null;
84200af8:	2a 62       	if NE jump (m) Lc_rtp_notify_ttp_5;

84200afa <Lc_rtp_notify_ttp_4>:
        /* notify only on requested intervals */
        return;
    }

    /* Get the TTP state params */
    ttp_get_state_params_status(opx_data->ttp_instance, &state_params, &ttp_resync_count);
84200afa:	44 11       	r2 = FP + 20;
84200afc:	43 14       	r1 = FP + 68;
84200afe:	b2 a8       	r0 = M[r4 + 72];
84200b00:	06 f0 21 e2 	call (m) $_ttp_get_state_params_status;

    L3_DBG_MSG5("Notify TTP params for RTP Seq %d, TTP = %4d, sra = 0x%08x, latency = %4d, resync_count= %d", opx_data->sequence_number, state_params.ttp, state_params.sp_adjustment, state_params.latency, ttp_resync_count);

    OPMSG_CREATION_FIELD_SET(ttp_notify_msg, OPMSG_REPLY_TTP_SEQ, SEQ_NUM, opx_data->sequence_number);
84200b04:	f1 88       	rMAC = M[r4 + 12];
84200b06:	31 de       	M[FP + 24] = rMAC;
    OPMSG_CREATION_FIELD_SET(ttp_notify_msg, OPMSG_REPLY_TTP_SEQ, SAMPLE_COUNT,(frame_data->nr_of_frames * frame_data->frame_samples));
84200b08:	f9 88       	rMAC = M[r5 + 12];
84200b0a:	ba 88       	r0 = M[r5 + 8];
84200b0c:	89 1a       	rMAC = rMAC * r0 (int);
84200b0e:	39 de       	M[FP + 28] = rMAC;
    OPMSG_CREATION_FIELD_SET_PAIR(ttp_notify_msg, OPMSG_REPLY_TTP_SEQ, TOTAL_NUM_PACKETS,opx_data->rtp_decode_packet_count);
84200b10:	71 b9       	rMAC = M[r4 + 116];
84200b12:	89 c6       	rMAC = rMAC AND 0xffff;
84200b14:	49 de       	M[FP + 36] = rMAC;
84200b16:	72 b9       	r0 = M[r4 + 116];
84200b18:	92 52       	r0 = r0 LSHIFT -16;
84200b1a:	42 de       	M[FP + 32] = r0;
    OPMSG_CREATION_FIELD_SET_PAIR(ttp_notify_msg, OPMSG_REPLY_TTP_SEQ, TTP_TIMESTAMP,state_params.ttp);
84200b1c:	8a d8       	r0 = M[FP + 68];
84200b1e:	91 c6       	rMAC = r0 AND 0xffff;
84200b20:	59 de       	M[FP + 44] = rMAC;
84200b22:	92 52       	r0 = r0 LSHIFT -16;
84200b24:	52 de       	M[FP + 40] = r0;
    OPMSG_CREATION_FIELD_SET_PAIR(ttp_notify_msg, OPMSG_REPLY_TTP_SEQ, LATENCY,state_params.latency);
84200b26:	9a d8       	r0 = M[FP + 76];
84200b28:	91 c6       	rMAC = r0 AND 0xffff;
84200b2a:	69 de       	M[FP + 52] = rMAC;
84200b2c:	92 5a       	r0 = r0 ASHIFT -16;
84200b2e:	62 de       	M[FP + 48] = r0;
    OPMSG_CREATION_FIELD_SET_PAIR(ttp_notify_msg, OPMSG_REPLY_TTP_SEQ, SP_ADJ,state_params.sp_adjustment);
84200b30:	92 d8       	r0 = M[FP + 72];
84200b32:	91 c6       	rMAC = r0 AND 0xffff;
84200b34:	79 de       	M[FP + 60] = rMAC;
84200b36:	92 5a       	r0 = r0 ASHIFT -16;
84200b38:	72 de       	M[FP + 56] = r0;
    OPMSG_CREATION_FIELD_SET(ttp_notify_msg, OPMSG_REPLY_TTP_SEQ, TTP_RESYNC_COUNT,ttp_resync_count);
84200b3a:	29 d8       	rMAC = M[FP + 20];
84200b3c:	81 de       	M[FP + 64] = rMAC;

    common_send_unsolicited_message( op_data, (unsigned)OPMSG_REPLY_ID_TTP_RTP_SEQ,
                                     OPMSG_REPLY_TTP_SEQ_WORD_SIZE,
                                     (unsigned*) ttp_notify_msg);
84200b3e:	85 11       	r3 = FP + 24;
84200b40:	c4 22       	r2 = Null + 11;
84200b42:	83 21       	r1 = Null + 6;
84200b44:	42 08       	r0 = r6 + Null;
84200b46:	ef fd fd ff 	call (m) 0x592;
84200b4a:	2d e2 

84200b4c <Lc_rtp_notify_ttp_5>:
}
84200b4c:	70 4c       	SP = SP + -64;
84200b4e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200b50:	d8 4c       	rts;

84200b52 <Lc_rtp_header_decode_1>:
 *
 * \param opx_data Pointer to the RTP operator data.
 * \param header_size RTP header size.
 */
static void rtp_header_decode(RTP_DECODE_OP_DATA *opx_data, unsigned header_size, RTP_HEADER_DATA *header)
{
84200b52:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84200b54:	1a 09       	r8 = r1 + Null;
84200b56:	26 00       	r4 = r2 + Null;

    tCbuffer *ip_buffer = opx_data->ip_buffer;
84200b58:	57 99       	r5 = M[r0 + 52];
    TIME rtp_timestamp;
    uint32 rtp_source;

    /* Get the sequence number */
    unpack_cbuff_to_array((int*)fixed_header, ip_buffer,
        RTP_FIXED_HEADER_TIMESTAMP_PART_LENGTH + RTP_FIXED_HEADER_SOURCE_PART_LENGTH);
84200b5a:	04 22       	r2 = Null + 8;
84200b5c:	c2 11       	r0 = FP + 28;
84200b5e:	3b 00       	r1 = r5 + Null;
84200b60:	04 f0 33 e7 	call (m) $_unpack_cbuff_to_array;

    /* The RTP timestamp field is actually a sample count.
     * This sample count should be used to generate the time to play
     * timestamp . */
    rtp_timestamp = (((uint32)fixed_header[0])<<24) + (fixed_header[1]<<16) + (fixed_header[2]<<8) + fixed_header[3];
84200b64:	3a d8       	r0 = M[FP + 28];
84200b66:	4b d8       	r1 = M[FP + 36];
84200b68:	44 d8       	r2 = M[FP + 32];
84200b6a:	52 57       	r0 = r0 LSHIFT 24;
84200b6c:	db 55       	r1 = r1 LSHIFT 8;
84200b6e:	a4 56       	r2 = r2 LSHIFT 16;
84200b70:	19 01       	rMAC = r1 + r2;
84200b72:	51 00       	rMAC = r0 + rMAC;
84200b74:	52 d8       	r0 = M[FP + 40];
84200b76:	2f f1 08 c0 	r6 = rMAC + r0;
    rtp_source = (((uint32)fixed_header[4])<<24) + (fixed_header[5]<<16) + (fixed_header[6]<<8) + fixed_header[7];
84200b7a:	5a d8       	r0 = M[FP + 44];
84200b7c:	6b d8       	r1 = M[FP + 52];
84200b7e:	64 d8       	r2 = M[FP + 48];
84200b80:	52 57       	r0 = r0 LSHIFT 24;
84200b82:	db 55       	r1 = r1 LSHIFT 8;
84200b84:	a4 56       	r2 = r2 LSHIFT 16;
84200b86:	19 01       	rMAC = r1 + r2;
84200b88:	51 00       	rMAC = r0 + rMAC;
84200b8a:	72 d8       	r0 = M[FP + 56];
84200b8c:	2f f1 09 c0 	r7 = rMAC + r0;

    /* Save the RTP timestamp */

    /* Discard the rest of the header. */
    cbuffer_advance_read_ptr_ex(ip_buffer, header_size -
            (RTP_FIXED_HEADER_FIRST_PART_LENGTH + RTP_FIXED_HEADER_TIMESTAMP_PART_LENGTH + RTP_FIXED_HEADER_SOURCE_PART_LENGTH));
84200b90:	a3 f3 f4 3b 	r1 = r8 + -12;
84200b94:	3a 00       	r0 = r5 + Null;
84200b96:	ff fd e0 f1 	call (m) 0x3ccc0;
84200b9a:	2b e9 
    header->timestamp = rtp_timestamp;
84200b9c:	68 f0 01 8e 	M[r4 + 4] = r6;
    header->source = rtp_source;
84200ba0:	69 f0 02 8e 	M[r4 + 8] = r7;

84200ba4 <Lc_rtp_header_decode_2>:
}
84200ba4:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84200ba6:	d8 4c       	rts;

84200ba8 <Lc_rtp_notify_latency_change_1>:


static void rtp_notify_latency_change(OPERATOR_DATA *op_data, uint32 source, TIME_INTERVAL latency)
{
84200ba8:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
    unsigned latency_changed_msg[OPMSG_REPLY_LATENCY_CHANGED_WORD_SIZE];

    L4_DBG_MSG2( "RTP decode target latency change %d for source %u is notified", latency, source );

    OPMSG_CREATION_FIELD_SET32(latency_changed_msg, OPMSG_REPLY_LATENCY_CHANGED, SOURCE_ID, source);
84200baa:	99 c6       	rMAC = r1 AND 0xffff;
84200bac:	11 de       	M[FP + 8] = rMAC;
84200bae:	9b 52       	r1 = r1 LSHIFT -16;
84200bb0:	1b de       	M[FP + 12] = r1;
    OPMSG_CREATION_FIELD_SET32(latency_changed_msg, OPMSG_REPLY_LATENCY_CHANGED, TARGET_LATENCY, latency);
84200bb2:	a1 c6       	rMAC = r2 AND 0xffff;
84200bb4:	a3 5a       	r1 = r2 ASHIFT -16;
84200bb6:	21 de       	M[FP + 16] = rMAC;
84200bb8:	2b de       	M[FP + 20] = r1;

    common_send_unsolicited_message( op_data, (unsigned)OPMSG_REPLY_ID_LATENCY_CHANGED,
                                     OPMSG_REPLY_LATENCY_CHANGED_WORD_SIZE,
                                     (unsigned*)latency_changed_msg);
84200bba:	85 10       	r3 = FP + 8;
84200bbc:	04 21       	r2 = Null + 4;
84200bbe:	43 21       	r1 = Null + 5;
84200bc0:	ef fd fc ff 	call (m) 0x592;
84200bc4:	33 ee 

84200bc6 <Lc_rtp_notify_latency_change_2>:
}
84200bc6:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
84200bc8:	d8 4c       	rts;

84200bca <Lc_rtp_source_changed_1>:
   Only reset on an SSRC change, as this is the step change in TTP
   The ttp_adjust change should just be applied so the TTP module can dynamically adjust
   ttp_adjust is being validate by the AOSP source device.
   */
static void rtp_source_changed(OPERATOR_DATA *op_data, uint32 source, TIME_INTERVAL ttp_adjust)
{
84200bca:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200bcc:	12 09       	r8 = r0 + Null;
84200bce:	1e 00       	r4 = r1 + Null;
84200bd0:	21 09       	r7 = r2 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200bd2:	ef fd fc ff 	call (m) 0x4e6;
84200bd6:	35 e8 
84200bd8:	10 09       	r6 = r0 + Null;
static void rtp_source_changed(OPERATOR_DATA *op_data, uint32 source, TIME_INTERVAL ttp_adjust)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    TIME_INTERVAL new_latency;
    unsigned count;
    bool reset = (opx_data->prev_src_id == source) ? FALSE : TRUE; // Reset only of SSRC change
84200bda:	81 f0 1c 88 	rMAC = M[r6 + 112];
84200bde:	03 09       	r9 = Null + Null;
84200be0:	88 05       	Null = rMAC - r4;
84200be2:	21 f0 4b ce 	if NE r9 = Null + 1;
    opx_data->prev_src_id = source;
84200be6:	86 f0 1c 8e 	M[r6 + 112] = r4;
    opx_data->rtp_ttp_adjust = ttp_adjust;
84200bea:	89 f0 20 8e 	M[r6 + 128] = r7;

    if (opx_data->src_latency_map != NULL)
84200bee:	84 f0 1b 88 	r2 = M[r6 + 108];
84200bf2:	38 60       	if EQ jump (m) Lc_rtp_source_changed_12;

84200bf4 <Lc_rtp_source_changed_2>:
84200bf4:	23 e8       	r1 = M[r2 + Null];
    {
        for (count = 0; count < opx_data->src_latency_map->num_entries; count++)
84200bf6:	02 00       	r0 = Null + Null;
84200bf8:	21 21       	rMAC = r2 + 4;
84200bfa:	03 6e       	jump (m) Lc_rtp_source_changed_4;

84200bfc <Lc_rtp_source_changed_3>:
84200bfc:	52 20       	r0 = r0 + 1;
84200bfe:	09 22       	rMAC = rMAC + 8;

84200c00 <Lc_rtp_source_changed_4>:
84200c00:	d0 04       	Null = r0 - r1;
84200c02:	02 f0 e1 e0 	if C jump (m) Lc_rtp_source_changed_12;

84200c06 <Lc_rtp_source_changed_5>:
        {
            if (opx_data->src_latency_map->entries[count].source_id == source)
84200c06:	6f f1 00 c3 	Null = M[rMAC] - r4;
84200c0a:	f9 63       	if NE jump (m) Lc_rtp_source_changed_3;

84200c0c <Lc_rtp_source_changed_6>:
            {
                new_latency = opx_data->src_latency_map->entries[count].target_latency;
84200c0c:	92 54       	r0 = r0 LSHIFT 3;
84200c0e:	14 01       	r2 = r0 + r2;
84200c10:	a7 88       	r5 = M[r2 + 8];
                new_latency += opx_data->rtp_ttp_adjust * MILLISECOND;
84200c12:	03 f0 e8 f9 	rMAC = r7 * 1000 (int);
84200c16:	91 d9 
84200c18:	cf 01       	r5 = rMAC + r5;
                L2_DBG_MSG2("RTP decode target latency changed to %d for source %u", new_latency, source);
84200c1a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200c1e:	88 24       	Null = rMAC - 2;
84200c20:	09 68       	if LT jump (m) Lc_rtp_source_changed_8;

84200c22 <Lc_rtp_source_changed_7>:
84200c22:	55 f1 02 f0 	r0 = Null + 357564416;
84200c26:	00 40 
84200c28:	34 00       	r2 = r4 + Null;
84200c2a:	3b 00       	r1 = r5 + Null;
84200c2c:	ff fd 00 f0 	call (m) 0xcf2;
84200c30:	27 e6 

84200c32 <Lc_rtp_source_changed_8>:
                /* Notify the latency change */
                if( opx_data->latency_change_notify_enable == 1)
84200c32:	82 f0 10 82 	r0 = MBU[r6 + 16];
84200c36:	12 50       	r0 = r0 LSHIFT -1;
84200c38:	11 c0       	rMAC = r0 AND 0x1;
84200c3a:	05 60       	if EQ jump (m) Lc_rtp_source_changed_10;

84200c3c <Lc_rtp_source_changed_9>:
                {
                    rtp_notify_latency_change( op_data, source, new_latency );
84200c3c:	3c 00       	r2 = r5 + Null;
84200c3e:	33 00       	r1 = r4 + Null;
84200c40:	52 08       	r0 = r8 + Null;
84200c42:	b3 4f       	call (m) Lc_rtp_notify_latency_change_1;

84200c44 <Lc_rtp_source_changed_10>:
                }

                ttp_configure_latency(opx_data->ttp_instance, new_latency);
84200c44:	82 f0 12 88 	r0 = M[r6 + 72];
84200c48:	3b 00       	r1 = r5 + Null;
84200c4a:	ff fd c4 f0 	call (m) 0x195a8;
84200c4e:	3f ea 
                if (reset)
84200c50:	0f fb 00 c2 	Null = r9 - Null;
84200c54:	12 60       	if EQ jump (m) Lc_rtp_source_changed_14;

84200c56 <Lc_rtp_source_changed_11>:
                    ttp_reset(opx_data->ttp_instance);
84200c56:	82 f0 12 88 	r0 = M[r6 + 72];
84200c5a:	ff fd c4 f0 	call (m) 0x19488;
84200c5e:	2f e1 
84200c60:	0c 6e       	jump (m) Lc_rtp_source_changed_14;

84200c62 <Lc_rtp_source_changed_12>:
                return;
            }
        }
    }
    L2_DBG_MSG1("RTP decode: no latency target for source %u, target unchanged", source);
84200c62:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200c66:	88 24       	Null = rMAC - 2;
84200c68:	08 68       	if LT jump (m) Lc_rtp_source_changed_14;

84200c6a <Lc_rtp_source_changed_13>:
84200c6a:	55 f1 02 f0 	r0 = Null + 357564470;
84200c6e:	36 40 
84200c70:	33 00       	r1 = r4 + Null;
84200c72:	ff fd 00 f0 	call (m) 0xcde;
84200c76:	2d e3 

84200c78 <Lc_rtp_source_changed_14>:
}
84200c78:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200c7a:	d8 4c       	rts;

84200c7c <Lc_rtp_decode_reset_working_data_1>:
 * Initialise various working data parameters for the RTP operator.
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_decode_reset_working_data(OPERATOR_DATA *op_data)
{
84200c7c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200c7e:	ef fd fc ff 	call (m) 0x4e6;
84200c82:	29 e3 
84200c84:	16 00       	r4 = r0 + Null;
 */
static void rtp_decode_reset_working_data(OPERATOR_DATA *op_data)
{
    RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

    opx_data->ip_format = AUDIO_DATA_FORMAT_ENCODED_DATA;
84200c86:	41 23       	rMAC = Null + 13;
84200c88:	31 ee       	M[r4 + Null] = rMAC;
    opx_data->op_format = AUDIO_DATA_FORMAT_ENCODED_DATA;
84200c8a:	71 8e       	M[r4 + 4] = rMAC;

    /* Set the default working mode as RTP header stripping. */
    opx_data->mode = RTP_STRIP;
84200c8c:	81 20       	rMAC = Null + 2;
84200c8e:	31 9a       	MB[r4 + 8] = rMAC;

    /* Disable content protection by default. */
    opx_data->scms_enable = 0;
84200c90:	31 a2       	rMAC = MBU[r4 + 16];
84200c92:	11 ff fe 1f 	rMAC = rMAC AND 0xfffffffe;

    /* disable letency notification */
    opx_data->latency_change_notify_enable = 0;
84200c96:	11 ff fd 1f 	rMAC = rMAC AND 0xfffffffd;
84200c9a:	31 aa       	MB[r4 + 16] = rMAC;

    /* For the moment the default code is SBC. */
    opx_data->codec_type = SBC;
84200c9c:	41 20       	rMAC = Null + 1;
84200c9e:	71 aa       	MB[r4 + 17] = rMAC;

    rtp_set_payload_header_size(opx_data);
84200ca0:	fe ff 39 ef 	call (m) Lc_rtp_set_payload_header_size_1;
#ifdef DEBUG_RTP_DECODE
    opx_data->rtp_decode_last_tag_index = -1;
84200ca4:	41 24       	rMAC = Null - 1;
84200ca6:	f1 9e       	M[r4 + 44] = rMAC;
    opx_data->rtp_decode_last_tag_length = -1;
84200ca8:	31 9f       	M[r4 + 48] = rMAC;
#endif

    /* disable ttp notification */
    opx_data->ttp_notification_interval = 0;
84200caa:	f0 bf       	M[r4 + 124] = Null;

    /* reset the packet count */
    opx_data->rtp_decode_packet_count = 0;
84200cac:	70 bf       	M[r4 + 116] = Null;

84200cae <Lc_rtp_decode_reset_working_data_2>:
}
84200cae:	f1 48       	popm <FP, r4, rLink>;
84200cb0:	d8 4c       	rts;

84200cb2 <Lc_get_read_index_from_buff_1>:
/*
 * Returns the read index for a buffer. Supports 32-bit packed and
 * 16-bit unpacked data.
 */
static unsigned int get_read_index_from_buff(tCbuffer *cbuffer)
{
84200cb2:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned int read_index;
#ifndef DATAFORMAT_32
    unsigned int offset;
#endif /* !DATAFORMAT_32 */
    read_index = cbuffer_get_read_offset_ex(cbuffer);
84200cb4:	ff fd 5c f1 	call (m) 0x2c610;
84200cb8:	3d ea 

84200cba <Lc_get_read_index_from_buff_2>:
    /* Convert the words to usable octets. */
    read_index = read_index << 1;
    read_index += offset;
#endif /* !DATAFORMAT_32 */

    return read_index;
84200cba:	c8 48       	popm <FP, rLink>;
84200cbc:	d8 4c       	rts;

84200cbe <Lc_tag_valid_1>:
 *
 * \param tag Pointer to the metadata tag read from the input buffer.
 * \param opx_data Pointer to the RTP operator data.
 */
static bool tag_valid(metadata_tag* tag, RTP_DECODE_OP_DATA *opx_data )
{
84200cbe:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84200cc0:	17 00       	r5 = r0 + Null;
84200cc2:	1e 00       	r4 = r1 + Null;

    if (get_read_index_from_buff(opx_data->ip_buffer) != tag->index )
84200cc4:	72 99       	r0 = M[r4 + 52];
84200cc6:	f6 4f       	call (m) Lc_get_read_index_from_buff_1;
84200cc8:	b9 88       	rMAC = M[r5 + 8];
84200cca:	50 04       	Null = r0 - rMAC;
84200ccc:	28 60       	if EQ jump (m) Lc_tag_valid_5;

84200cce <Lc_tag_valid_2>:
        unsigned discard_buffer;
        unsigned discard_metadata;
        unsigned octets_2_first_tag, octets_post_last_tag;
        metadata_tag  *tag_list;
        /* Probably the metadata and the buffer will have different amount of data. */
        discard_buffer = cbuffer_calc_amount_data_ex(opx_data->ip_buffer);
84200cce:	72 99       	r0 = M[r4 + 52];
84200cd0:	ff fd df f1 	call (m) 0x3cad6;
84200cd4:	27 e0 
84200cd6:	10 09       	r6 = r0 + Null;
        cbuffer_advance_read_ptr_ex(opx_data->ip_buffer, discard_buffer);
84200cd8:	72 99       	r0 = M[r4 + 52];
84200cda:	43 08       	r1 = r6 + Null;
84200cdc:	ff fd df f1 	call (m) 0x3ccc0;
84200ce0:	25 ef 

        discard_metadata = buff_metadata_available_octets(opx_data->ip_buffer);
84200ce2:	72 99       	r0 = M[r4 + 52];
84200ce4:	ff fd 9e f0 	call (m) 0x14958;
84200ce8:	35 e3 
84200cea:	17 00       	r5 = r0 + Null;
        tag_list = buff_metadata_remove(opx_data->ip_buffer, discard_metadata, &octets_2_first_tag, &octets_post_last_tag);
84200cec:	85 11       	r3 = FP + 24;
84200cee:	44 11       	r2 = FP + 20;
84200cf0:	72 99       	r0 = M[r4 + 52];
84200cf2:	3b 00       	r1 = r5 + Null;
84200cf4:	ff fd 9e f0 	call (m) 0x149ca;
84200cf8:	37 e6 
        buff_metadata_tag_list_delete(tag_list);
84200cfa:	ff fd 9c f0 	call (m) 0x145ee;
84200cfe:	35 e7 

        L2_DBG_MSG2("RTP Decode buffer out of sink. discard_buffer = %d, discard_metadata =%d",
                discard_buffer, discard_metadata);
84200d00:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200d04:	88 24       	Null = rMAC - 2;
84200d06:	09 68       	if LT jump (m) Lc_tag_valid_4;

84200d08 <Lc_tag_valid_3>:
84200d08:	55 f1 02 f0 	r0 = Null + 357564532;
84200d0c:	74 40 
84200d0e:	3c 00       	r2 = r5 + Null;
84200d10:	43 08       	r1 = r6 + Null;
84200d12:	ef fd ff ff 	call (m) 0xcf2;
84200d16:	21 ef 

84200d18 <Lc_tag_valid_4>:
        return FALSE;
84200d18:	02 00       	r0 = Null + Null;
84200d1a:	05 6e       	jump (m) Lc_tag_valid_6;

84200d1c <Lc_tag_valid_5>:
    }
#ifdef DEBUG_RTP_DECODE
    opx_data->rtp_decode_last_tag_index = tag->index;
84200d1c:	f1 9e       	M[r4 + 44] = rMAC;
    opx_data->rtp_decode_last_tag_length = tag->length;
84200d1e:	f9 88       	rMAC = M[r5 + 12];
84200d20:	31 9f       	M[r4 + 48] = rMAC;
#endif
    return TRUE;
84200d22:	42 20       	r0 = Null + 1;

84200d24 <Lc_tag_valid_6>:
}
84200d24:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84200d26:	d8 4c       	rts;

84200d28 <Lc_get_tag_size_1>:
 *
 * \param tag Pointer to the metadata tag read from the input buffer.
 */
static unsigned int get_tag_size(metadata_tag* tag)
{
    if (tag == NULL)
84200d28:	10 04       	Null = r0 - Null;
84200d2a:	03 62       	if NE jump (m) Lc_get_tag_size_3;

84200d2c <Lc_get_tag_size_2>:
    {
        return 0;
84200d2c:	02 00       	r0 = Null + Null;
84200d2e:	02 6e       	jump (m) Lc_get_tag_size_4;

84200d30 <Lc_get_tag_size_3>:
    }
    return tag->length;
84200d30:	d2 88       	r0 = M[r0 + 12];

84200d32 <Lc_get_tag_size_4>:
84200d32:	d8 4c       	rts;

84200d34 <Lc_delete_consumed_metadata_tag_1>:
 *
 * \param o_buff Pointer to the octet buffer from which the tag will be consumed.
 * \param octets_consumed Octets consumed from the buffer. Must be only one tag.
 */
static void delete_consumed_metadata_tag(tCbuffer *o_buff, unsigned int  octets_consumed)
{
84200d34:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
84200d36:	1e 00       	r4 = r1 + Null;

    unsigned int octets_b4idx, octets_afteridx;

    metadata_tag *tag = buff_metadata_remove(o_buff, octets_consumed, &octets_b4idx , &octets_afteridx);
84200d38:	05 11       	r3 = FP + 16;
84200d3a:	c4 10       	r2 = FP + 12;
84200d3c:	ff fd 9e f0 	call (m) 0x149ca;
84200d40:	2f e4 

    /* get_next_tag_size checks if the tag is at the beginning of the buffer. Therefore
     * octets_b4idx will be 0.*/
    /* Check metadata is synced */
    PL_ASSERT(tag != NULL);
84200d42:	10 04       	Null = r0 - Null;
84200d44:	09 62       	if NE jump (m) Lc_delete_consumed_metadata_tag_3;

84200d46 <Lc_delete_consumed_metadata_tag_2>:
84200d46:	03 f0 ae 41 	r1 = Null + 430;
84200d4a:	02 f0 13 60 	r0 = Null + 4115;
84200d4e:	ff fd b1 f0 	call (m) 0x16ff0;
84200d52:	23 e5 
84200d54:	15 6e       	jump (m) Lc_delete_consumed_metadata_tag_7;

84200d56 <Lc_delete_consumed_metadata_tag_3>:
    PL_ASSERT(octets_b4idx == 0);
84200d56:	18 d8       	Null = M[FP + 12];
84200d58:	09 60       	if EQ jump (m) Lc_delete_consumed_metadata_tag_5;

84200d5a <Lc_delete_consumed_metadata_tag_4>:
84200d5a:	03 f0 af 41 	r1 = Null + 431;
84200d5e:	02 f0 13 60 	r0 = Null + 4115;
84200d62:	ff fd b1 f0 	call (m) 0x16ff0;
84200d66:	2f e4 
84200d68:	0b 6e       	jump (m) Lc_delete_consumed_metadata_tag_7;

84200d6a <Lc_delete_consumed_metadata_tag_5>:
    PL_ASSERT(octets_afteridx == octets_consumed);
84200d6a:	21 d8       	rMAC = M[FP + 16];
84200d6c:	88 05       	Null = rMAC - r4;
84200d6e:	08 60       	if EQ jump (m) Lc_delete_consumed_metadata_tag_7;

84200d70 <Lc_delete_consumed_metadata_tag_6>:
84200d70:	03 f0 b0 41 	r1 = Null + 432;
84200d74:	02 f0 13 60 	r0 = Null + 4115;
84200d78:	ff fd b1 f0 	call (m) 0x16ff0;
84200d7c:	39 e3 

84200d7e <Lc_delete_consumed_metadata_tag_7>:

    buff_metadata_delete_tag(tag, TRUE);
84200d7e:	43 20       	r1 = Null + 1;
84200d80:	ff fd 9c f0 	call (m) 0x1459c;
84200d84:	3d e0 

84200d86 <Lc_delete_consumed_metadata_tag_9>:
}
84200d86:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
84200d88:	d8 4c       	rts;

84200d8a <Lc_get_time_of_arrival_1>:
/**
 * Returns the time of arrival of the tag. If the time of arrival is not set for the tag
 * the hal get time is used.
 */
static unsigned get_time_of_arrival( metadata_tag* tag)
{
84200d8a:	c8 1c       	pushm <FP(=SP), rLink>;
    if (IS_TIME_OF_ARRIVAL_TAG(tag))
84200d8c:	51 88       	rMAC = M[r0 + 4];
84200d8e:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84200d92:	10 f0 40 24 	Null = rMAC - 64;
84200d96:	03 62       	if NE jump (m) Lc_get_time_of_arrival_3;

84200d98 <Lc_get_time_of_arrival_2>:
    {
        return tag->timestamp;
84200d98:	12 89       	r0 = M[r0 + 16];
84200d9a:	04 6e       	jump (m) Lc_get_time_of_arrival_4;

84200d9c <Lc_get_time_of_arrival_3>:
    }
    else
    {
        /* Maybe we are connected to a tester/file endpoint.*/
        return time_get_time();
84200d9c:	ff fd 29 f0 	call (m) 0x6100;
84200da0:	25 eb 

84200da2 <Lc_get_time_of_arrival_4>:
    }
}
84200da2:	c8 48       	popm <FP, rLink>;
84200da4:	d8 4c       	rts;

84200da6 <Lc_transport_metadata_tag_1>:
 * \param frame_data Pointer frame header decode data.
 * \param packet_size Size of the tag from the input buffer.
 */
static void transport_metadata_tag(RTP_DECODE_OP_DATA *opx_data, RTP_FRAME_DECODE_DATA* frame_data,
        unsigned packet_size)
{
84200da6:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200da8:	4c 4c       	SP = SP + 48;
84200daa:	12 09       	r8 = r0 + Null;
84200dac:	19 09       	r7 = r1 + Null;
84200dae:	26 00       	r4 = r2 + Null;
    tCbuffer *clone_buffer;
    tCbuffer *buffer;
    tCbuffer* ip_buffer = opx_data->ip_buffer;
84200db0:	a2 f0 0d 88 	r0 = M[r8 + 52];
    unsigned octets_2_first_tag, octets_post_last_tag;
    unsigned frame_length = frame_data->frame_length;
84200db4:	9b f0 01 88 	r9 = M[r7 + 4];
    metadata_tag  *tag;
    ttp_status status;

    patch_fn_shared(rtp_decode);
    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84200db8:	a0 f0 1a 88 	Null = M[r8 + 104];
84200dbc:	08 60       	if EQ jump (m) Lc_transport_metadata_tag_3;

84200dbe <Lc_transport_metadata_tag_2>:
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84200dbe:	a1 f0 0f 88 	rMAC = M[r8 + 60];
84200dc2:	41 de       	M[FP + 32] = rMAC;
        buffer = opx_data->u.pack.frame_buffer;
84200dc4:	a1 f0 10 88 	rMAC = M[r8 + 64];
84200dc8:	49 de       	M[FP + 36] = rMAC;
84200dca:	07 6e       	jump (m) Lc_transport_metadata_tag_4;

84200dcc <Lc_transport_metadata_tag_3>:
    }
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
84200dcc:	a1 f0 0f 88 	rMAC = M[r8 + 60];
84200dd0:	41 de       	M[FP + 32] = rMAC;
        buffer = opx_data->op_buffer;
84200dd2:	a1 f0 0e 88 	rMAC = M[r8 + 56];
84200dd6:	49 de       	M[FP + 36] = rMAC;

84200dd8 <Lc_transport_metadata_tag_4>:



    /* Remove the tag consumed in this cycle.
     */
    tag = buff_metadata_remove(ip_buffer, packet_size, &octets_2_first_tag, &octets_post_last_tag);
84200dd8:	45 13       	r3 = FP + 52;
84200dda:	04 13       	r2 = FP + 48;
84200ddc:	33 00       	r1 = r4 + Null;
84200dde:	ff fd 9d f0 	call (m) 0x149ca;
84200de2:	2d ef 
84200de4:	52 de       	M[FP + 40] = r0;

    PL_ASSERT(octets_2_first_tag == 0);
84200de6:	60 d8       	Null = M[FP + 48];
84200de8:	09 60       	if EQ jump (m) Lc_transport_metadata_tag_6;

84200dea <Lc_transport_metadata_tag_5>:
84200dea:	03 f0 f3 41 	r1 = Null + 499;
84200dee:	02 f0 13 60 	r0 = Null + 4115;
84200df2:	ff fd b0 f0 	call (m) 0x16ff0;
84200df6:	3f ef 
84200df8:	58 6e       	jump (m) Lc_transport_metadata_tag_26;

84200dfa <Lc_transport_metadata_tag_6>:
    PL_ASSERT(octets_post_last_tag == packet_size);
84200dfa:	69 d8       	rMAC = M[FP + 52];
84200dfc:	88 05       	Null = rMAC - r4;
84200dfe:	09 60       	if EQ jump (m) Lc_transport_metadata_tag_8;

84200e00 <Lc_transport_metadata_tag_7>:
84200e00:	03 f0 f4 41 	r1 = Null + 500;
84200e04:	02 f0 13 60 	r0 = Null + 4115;
84200e08:	ff fd b0 f0 	call (m) 0x16ff0;
84200e0c:	29 ef 
84200e0e:	4d 6e       	jump (m) Lc_transport_metadata_tag_26;

84200e10 <Lc_transport_metadata_tag_8>:
    PL_ASSERT((tag != NULL) && (tag->next == NULL));
84200e10:	51 d8       	rMAC = M[FP + 40];
84200e12:	44 60       	if EQ jump (m) Lc_transport_metadata_tag_25;

84200e14 <Lc_transport_metadata_tag_9>:
84200e14:	51 d8       	rMAC = M[FP + 40];
84200e16:	09 e8       	rMAC = M[rMAC + Null];
84200e18:	41 62       	if NE jump (m) Lc_transport_metadata_tag_25;

84200e1a <Lc_transport_metadata_tag_10>:

    if (opx_data->codec_type == AAC)
84200e1a:	a1 f0 11 80 	rMAC = MBS[r8 + 17];
84200e1e:	08 25       	Null = rMAC - 4;
84200e20:	2f 62       	if NE jump (m) Lc_transport_metadata_tag_21;

84200e22 <Lc_transport_metadata_tag_11>:
    {
        unsigned clone_buf_avail_octets = cbuffer_calc_amount_data_ex(clone_buffer);
84200e22:	42 d8       	r0 = M[FP + 32];
84200e24:	ff fd de f1 	call (m) 0x3cad6;
84200e28:	33 e5 
84200e2a:	16 00       	r4 = r0 + Null;
        /* There shouln't be more than one AAC frames in the clone buffer. */
        if (frame_data->nr_of_frames > 1)
84200e2c:	93 f0 03 88 	r1 = M[r7 + 12];
84200e30:	58 24       	Null = r1 - 1;
84200e32:	09 f0 9f e0 	if LS jump (m) Lc_transport_metadata_tag_15;

84200e36 <Lc_transport_metadata_tag_12>:
        {
            L2_DBG_MSG1("RTP decode: Number of AAC frames grater than 1! nr frames = %d",
                    frame_data->nr_of_frames);
84200e36:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200e3a:	88 24       	Null = rMAC - 2;
84200e3c:	07 68       	if LT jump (m) Lc_transport_metadata_tag_14;

84200e3e <Lc_transport_metadata_tag_13>:
84200e3e:	55 f1 02 f0 	r0 = Null + 357564605;
84200e42:	bd 40 
84200e44:	ef fd ff ff 	call (m) 0xcde;
84200e48:	3b e4 

84200e4a <Lc_transport_metadata_tag_14>:
            frame_data->nr_of_frames = 1;
84200e4a:	41 20       	rMAC = Null + 1;
84200e4c:	91 f0 03 8e 	M[r7 + 12] = rMAC;

84200e50 <Lc_transport_metadata_tag_15>:
        /* Mark the frame as invalid if the frame length is different from the available
         * octets in the clone buffer. Note: Only do this if the frame data is valid
         * and if we have at least one frames in the clone buffer. */
        if ((frame_data->valid) &&
            (frame_data->nr_of_frames > 0) &&
            (frame_length != clone_buf_avail_octets) )
84200e50:	90 f0 00 e8 	Null = M[r7 + Null];
84200e54:	b0 60       	if EQ jump (m) Lc_transport_metadata_tag_41;

84200e56 <Lc_transport_metadata_tag_16>:
84200e56:	90 f0 03 88 	Null = M[r7 + 12];
84200e5a:	12 60       	if EQ jump (m) Lc_transport_metadata_tag_21;

84200e5c <Lc_transport_metadata_tag_17>:
84200e5c:	6f fb 00 c2 	Null = r9 - r4;
84200e60:	0f 60       	if EQ jump (m) Lc_transport_metadata_tag_21;

84200e62 <Lc_transport_metadata_tag_18>:
        {
            L2_DBG_MSG2("RTP decode: AAC frame length = %d is different from the payload length= %d",
                frame_length, clone_buf_avail_octets);
84200e62:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200e66:	88 24       	Null = rMAC - 2;
84200e68:	09 68       	if LT jump (m) Lc_transport_metadata_tag_20;

84200e6a <Lc_transport_metadata_tag_19>:
84200e6a:	55 f1 02 f0 	r0 = Null + 357564668;
84200e6e:	fc 40 
84200e70:	34 00       	r2 = r4 + Null;
84200e72:	5b 08       	r1 = r9 + Null;
84200e74:	ef fd ff ff 	call (m) 0xcf2;
84200e78:	3f e3 

84200e7a <Lc_transport_metadata_tag_20>:
            frame_data->valid = FALSE;
84200e7a:	90 f0 00 ee 	M[r7 + Null] = Null;

84200e7e <Lc_transport_metadata_tag_21>:
        }
    }

    if ((frame_data->valid) && (frame_data->nr_of_frames > 0))
84200e7e:	90 f0 00 e8 	Null = M[r7 + Null];
84200e82:	99 60       	if EQ jump (m) Lc_transport_metadata_tag_41;

84200e84 <Lc_transport_metadata_tag_22>:
84200e84:	90 f0 03 88 	Null = M[r7 + 12];
84200e88:	88 60       	if EQ jump (m) Lc_transport_metadata_tag_40;

84200e8a <Lc_transport_metadata_tag_23>:
        unsigned count;
        unsigned total_encoded_data;
        metadata_tag *last_tag, *tag_list, *new_tag;
        unsigned time_of_arrival;

        if (opx_data->continuation_for_frame)
84200e8a:	a0 f0 06 88 	Null = M[r8 + 24];
84200e8e:	0d 60       	if EQ jump (m) Lc_transport_metadata_tag_26;

84200e90 <Lc_transport_metadata_tag_24>:
        {
            time_of_arrival = opx_data->first_tag_time_of_arrival;
84200e90:	a3 f0 07 88 	r1 = M[r8 + 28];
            opx_data->continuation_for_frame = FALSE;
84200e94:	a0 f0 06 8e 	M[r8 + 24] = Null;
84200e98:	0b 6e       	jump (m) Lc_transport_metadata_tag_28;

84200e9a <Lc_transport_metadata_tag_25>:
     */
    tag = buff_metadata_remove(ip_buffer, packet_size, &octets_2_first_tag, &octets_post_last_tag);

    PL_ASSERT(octets_2_first_tag == 0);
    PL_ASSERT(octets_post_last_tag == packet_size);
    PL_ASSERT((tag != NULL) && (tag->next == NULL));
84200e9a:	03 f0 f5 41 	r1 = Null + 501;
84200e9e:	02 f0 13 60 	r0 = Null + 4115;
84200ea2:	ff fd b0 f0 	call (m) 0x16ff0;
84200ea6:	2f ea 

84200ea8 <Lc_transport_metadata_tag_26>:
            time_of_arrival = opx_data->first_tag_time_of_arrival;
            opx_data->continuation_for_frame = FALSE;
        }
        else
        {
            time_of_arrival = get_time_of_arrival(tag);
84200ea8:	52 d8       	r0 = M[FP + 40];
84200eaa:	70 4f       	call (m) Lc_get_time_of_arrival_1;
84200eac:	13 00       	r1 = r0 + Null;

84200eae <Lc_transport_metadata_tag_28>:
        }

        /* Get the timestamp and sp adjust from the TTP module. Cannot put these two calls
         * to the for loop because the compiler gives status potentially unitialised. */
#ifndef TTP_SOURCE_TIME_TEST
        if (frame_data->frame_samples != 0)
84200eae:	91 f0 02 88 	rMAC = M[r7 + 8];
84200eb2:	0b 60       	if EQ jump (m) Lc_transport_metadata_tag_30;

84200eb4 <Lc_transport_metadata_tag_29>:
        {
        ttp_update_ttp(opx_data->ttp_instance, time_of_arrival,
                frame_data->nr_of_frames * frame_data->frame_samples, &status);
84200eb4:	85 13       	r3 = FP + 56;
84200eb6:	92 f0 03 88 	r0 = M[r7 + 12];
84200eba:	54 1a       	r2 = r0 * rMAC (int);
84200ebc:	a2 f0 12 88 	r0 = M[r8 + 72];
84200ec0:	ff fd c3 f0 	call (m) 0x1962e;
84200ec4:	2f eb 
84200ec6:	09 6e       	jump (m) Lc_transport_metadata_tag_31;

84200ec8 <Lc_transport_metadata_tag_30>:
        }
        else
#endif
        {
            ttp_update_ttp_from_source_time(opx_data->ttp_instance, time_of_arrival,
                    frame_data->rtp_timestamp, &status);
84200ec8:	85 13       	r3 = FP + 56;
84200eca:	94 f0 04 88 	r2 = M[r7 + 16];
84200ece:	a2 f0 12 88 	r0 = M[r8 + 72];
84200ed2:	ff fd c4 f0 	call (m) 0x19884;
84200ed6:	33 ed 

84200ed8 <Lc_transport_metadata_tag_31>:
        }

        L5_DBG_MSG2("Updated TTP status TTP = %4d, sra = %08x", status.ttp, status.sp_adjustment);
        new_tag = tag_list = last_tag = tag;
84200ed8:	e8 f0 0a 88 	r6 = M[FP + 40];
84200edc:	41 08       	rMAC = r6 + Null;

        patch_fn_shared(rtp_decode);

        METADATA_TIME_OF_ARRIVAL_UNSET(tag);
84200ede:	0a 00       	r0 = rMAC + Null;
84200ee0:	49 88       	rMAC = M[rMAC + 4];
84200ee2:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84200ee6:	51 8e       	M[r0 + 4] = rMAC;
        /* Populate the new metadata tag. */
        ttp_utils_populate_tag(new_tag, &status);
84200ee8:	83 13       	r1 = FP + 56;
84200eea:	ef fd fe ff 	call (m) 0xbe6;
84200eee:	3d e7 

        /* Make sure only one tag gets the stream start flag */
        status.stream_restart = FALSE;
84200ef0:	88 de       	M[FP + 68] = Null;

        if (opx_data->codec_type == SBC)
84200ef2:	a1 f0 11 80 	rMAC = MBS[r8 + 17];
84200ef6:	48 24       	Null = rMAC - 1;
84200ef8:	09 62       	if NE jump (m) Lc_transport_metadata_tag_33;

84200efa <Lc_transport_metadata_tag_32>:
        {
            frame_length = frame_data->frame_length_extra[0];
84200efa:	91 f0 06 88 	rMAC = M[r7 + 24];
84200efe:	1b f0 00 e6 	r9 = MHU[rMAC + Null];
            total_encoded_data = frame_data->total_encoded_data;
84200f02:	91 f0 0b 86 	rMAC = MHU[r7 + 22];
84200f06:	59 de       	M[FP + 44] = rMAC;
84200f08:	06 6e       	jump (m) Lc_transport_metadata_tag_34;

84200f0a <Lc_transport_metadata_tag_33>:
        }
        else
        {
            total_encoded_data = frame_length * frame_data->nr_of_frames;
84200f0a:	91 f0 03 88 	rMAC = M[r7 + 12];
84200f0e:	00 fb b1 c9 	rMAC = rMAC * r9 (int);
84200f12:	59 de       	M[FP + 44] = rMAC;

84200f14 <Lc_transport_metadata_tag_34>:
        }
            new_tag->length = frame_length;
84200f14:	51 d8       	rMAC = M[FP + 40];
84200f16:	1b f0 03 8e 	M[rMAC + 12] = r9;

        /* Extrapolate the timestamps to the newly added tags. For one sbc frame only
         * there is no need to do anything. */
        for(count = 1; count < frame_data->nr_of_frames; count++)
84200f1a:	46 20       	r4 = Null + 1;

84200f1c <Lc_transport_metadata_tag_35>:
84200f1c:	91 f0 03 88 	rMAC = M[r7 + 12];
84200f20:	70 04       	Null = r4 - rMAC;
84200f22:	02 f0 d3 e0 	if C jump (m) Lc_transport_metadata_tag_39;

84200f26 <Lc_transport_metadata_tag_36>:
        {
            /* The first tag is allocated outside the for loop.*/
            new_tag = buff_metadata_new_tag();
84200f26:	ff fd 9b f0 	call (m) 0x1454e;
84200f2a:	29 e1 
84200f2c:	17 00       	r5 = r0 + Null;
            status.ttp = ttp_get_next_timestamp(status.ttp, frame_data->frame_samples,
                opx_data->sample_rate, status.sp_adjustment);
84200f2e:	7d d8       	r3 = M[FP + 60];
84200f30:	a4 f0 14 88 	r2 = M[r8 + 80];
84200f34:	93 f0 02 88 	r1 = M[r7 + 8];
84200f38:	72 d8       	r0 = M[FP + 56];
84200f3a:	ff fd c5 f0 	call (m) 0x19b02;
84200f3e:	29 ee 
84200f40:	72 de       	M[FP + 56] = r0;

            /* Populate the new metadata tag. */
            ttp_utils_populate_tag(new_tag, &status);
84200f42:	83 13       	r1 = FP + 56;
84200f44:	3a 00       	r0 = r5 + Null;
84200f46:	ef fd fe ff 	call (m) 0xbe6;
84200f4a:	21 e5 
            METADATA_PACKET_START_SET(new_tag);
84200f4c:	79 88       	rMAC = M[r5 + 4];
84200f4e:	c9 c8       	rMAC = rMAC OR 0x4;
            METADATA_PACKET_END_SET(new_tag);
84200f50:	49 c9       	rMAC = rMAC OR 0x8;
84200f52:	79 8e       	M[r5 + 4] = rMAC;
            if (opx_data->codec_type == SBC)
84200f54:	a1 f0 11 80 	rMAC = MBS[r8 + 17];
84200f58:	48 24       	Null = rMAC - 1;
84200f5a:	06 62       	if NE jump (m) Lc_transport_metadata_tag_38;

84200f5c <Lc_transport_metadata_tag_37>:
            {
                frame_length = frame_data->frame_length_extra[count];
84200f5c:	91 f0 06 88 	rMAC = M[r7 + 24];
84200f60:	32 54       	r0 = r4 LSHIFT 1;
84200f62:	1b f0 02 e6 	r9 = MHU[rMAC + r0];

84200f66 <Lc_transport_metadata_tag_38>:
            }

            new_tag->length = frame_length;
84200f66:	7b f0 03 8e 	M[r5 + 12] = r9;

            /* Add the new tag to the list. */
            last_tag->next = new_tag;
84200f6a:	87 f0 00 ee 	M[r6 + Null] = r5;
            last_tag = new_tag;
84200f6e:	38 09       	r6 = r5 + Null;
        }
            new_tag->length = frame_length;

        /* Extrapolate the timestamps to the newly added tags. For one sbc frame only
         * there is no need to do anything. */
        for(count = 1; count < frame_data->nr_of_frames; count++)
84200f70:	76 20       	r4 = r4 + 1;
84200f72:	d5 6f       	jump (m) Lc_transport_metadata_tag_35;

84200f74 <Lc_transport_metadata_tag_39>:

        }

        /* Append the tag to the frame buffer. Note: the after index is only the data
         * after the last index. */
        buff_metadata_append(buffer, tag_list, 0, frame_length);
84200f74:	04 00       	r2 = Null + Null;
84200f76:	5d 08       	r3 = r9 + Null;
84200f78:	53 d8       	r1 = M[FP + 40];
84200f7a:	4a d8       	r0 = M[FP + 36];
84200f7c:	ff fd 9c f0 	call (m) 0x147b8;
84200f80:	3d e1 
        /* Make the data available in the output buffer. */
        cbuffer_advance_write_ptr_ex(buffer, total_encoded_data);
84200f82:	5b d8       	r1 = M[FP + 44];
84200f84:	4a d8       	r0 = M[FP + 36];
84200f86:	ff fd de f1 	call (m) 0x3cc46;
84200f8a:	21 e6 
        /* Remove all the encoded data from the clone buffer. */
        cbuffer_advance_read_ptr_ex(clone_buffer, total_encoded_data);
84200f8c:	5b d8       	r1 = M[FP + 44];
84200f8e:	42 d8       	r0 = M[FP + 32];
84200f90:	ff fd de f1 	call (m) 0x3ccc0;
84200f94:	31 e9 
84200f96:	24 6e       	jump (m) Lc_transport_metadata_tag_43;

84200f98 <Lc_transport_metadata_tag_40>:
    }
    else if (frame_data->valid)
    {
        opx_data->continuation_for_frame = TRUE;
84200f98:	41 20       	rMAC = Null + 1;
84200f9a:	a1 f0 06 8e 	M[r8 + 24] = rMAC;
        opx_data->first_tag_time_of_arrival = get_time_of_arrival(tag);
84200f9e:	52 d8       	r0 = M[FP + 40];
84200fa0:	fe ff 2b ef 	call (m) Lc_get_time_of_arrival_1;
84200fa4:	a2 f0 07 8e 	M[r8 + 28] = r0;
        /* TODO can any information hold in the tag get lost. My concern is the end of
         * file marker. */
        buff_metadata_delete_tag(tag, TRUE);
84200fa8:	43 20       	r1 = Null + 1;
84200faa:	52 d8       	r0 = M[FP + 40];
84200fac:	ff fd 9a f0 	call (m) 0x1459c;
84200fb0:	31 ef 
84200fb2:	16 6e       	jump (m) Lc_transport_metadata_tag_43;

84200fb4 <Lc_transport_metadata_tag_41>:
    }
    else
    {
        opx_data->continuation_for_frame = FALSE;
84200fb4:	a0 f0 06 8e 	M[r8 + 24] = Null;
        /* A corrupt frame is in the input buffer. Discard it. Note we discard everything
         * accumulated in the clone buffer. */
        clone_buffer->write_ptr = buffer->write_ptr;
84200fb8:	49 d8       	rMAC = M[FP + 36];
84200fba:	42 d8       	r0 = M[FP + 32];
84200fbc:	89 88       	rMAC = M[rMAC + 8];
84200fbe:	91 8e       	M[r0 + 8] = rMAC;
        buff_metadata_delete_tag(tag, TRUE);
84200fc0:	43 20       	r1 = Null + 1;
84200fc2:	52 d8       	r0 = M[FP + 40];
84200fc4:	ff fd 9a f0 	call (m) 0x1459c;
84200fc8:	39 ee 

        L2_DBG_MSG("RTP decode corrupt frame discarded! ");
84200fca:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200fce:	88 24       	Null = rMAC - 2;
84200fd0:	07 68       	if LT jump (m) Lc_transport_metadata_tag_43;

84200fd2 <Lc_transport_metadata_tag_42>:
84200fd2:	55 f1 02 f0 	r0 = Null + 357564743;
84200fd6:	47 41 
84200fd8:	ef fd fe ff 	call (m) 0xccc;
84200fdc:	35 e7 

84200fde <Lc_transport_metadata_tag_43>:
    }

}
84200fde:	74 4c       	SP = SP + -48;
84200fe0:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200fe2:	d8 4c       	rts;

84200fe4 <Lc_rtp_create_internal_buffer_1>:

    return TRUE;
}

static tCbuffer *rtp_create_internal_buffer(int *base_addr, unsigned size, unsigned buffer_flags, unsigned usable_octets)
{
84200fe4:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200fe6:	19 00       	rMAC = r1 + Null;
84200fe8:	2e 00       	r4 = r3 + Null;
    tCbuffer *buffer;

    patch_fn_shared(rtp_decode);
    if (base_addr != NULL)
84200fea:	10 04       	Null = r0 - Null;
84200fec:	06 60       	if EQ jump (m) Lc_rtp_create_internal_buffer_3;

84200fee <Lc_rtp_create_internal_buffer_2>:
    {
        /* reuse the base */
        buffer = cbuffer_create(base_addr,
                size, buffer_flags);
84200fee:	ff fd 99 f0 	call (m) 0x1429c;
84200ff2:	2f e5 
84200ff4:	17 00       	r5 = r0 + Null;
84200ff6:	07 6e       	jump (m) Lc_rtp_create_internal_buffer_4;

84200ff8 <Lc_rtp_create_internal_buffer_3>:
    }
    else
    {
        /* create a new buffer */
        buffer = cbuffer_create_with_malloc(size, buffer_flags);
84200ff8:	23 00       	r1 = r2 + Null;
84200ffa:	0a 00       	r0 = rMAC + Null;
84200ffc:	ff fd 99 f0 	call (m) 0x142c6;
84201000:	2b e6 
84201002:	17 00       	r5 = r0 + Null;

84201004 <Lc_rtp_create_internal_buffer_4>:
    }
    if (buffer == NULL)
84201004:	38 04       	Null = r5 - Null;
84201006:	03 62       	if NE jump (m) Lc_rtp_create_internal_buffer_6;

84201008 <Lc_rtp_create_internal_buffer_5>:
    {
        return NULL;
84201008:	02 00       	r0 = Null + Null;
8420100a:	0c 6e       	jump (m) Lc_rtp_create_internal_buffer_8;

8420100c <Lc_rtp_create_internal_buffer_6>:
    }
    /* Allocate the metadata buffer. */
    if (buff_metadata_enable(buffer) == NULL)
8420100c:	ff fd 9d f0 	call (m) 0x14af2;
84201010:	27 e7 
84201012:	10 04       	Null = r0 - Null;
84201014:	fa 61       	if EQ jump (m) Lc_rtp_create_internal_buffer_5;

84201016 <Lc_rtp_create_internal_buffer_7>:
    {
        return NULL;
    }
    /* Note cbuffer_set_usable_octets will set the buffer size too. */
    cbuffer_set_usable_octets(buffer, usable_octets);
84201016:	33 00       	r1 = r4 + Null;
84201018:	3a 00       	r0 = r5 + Null;
8420101a:	ff fd 99 f0 	call (m) 0x1432e;
8420101e:	35 e8 

    return buffer;
84201020:	3a 00       	r0 = r5 + Null;

84201022 <Lc_rtp_create_internal_buffer_8>:
}
84201022:	f2 48       	popm <FP, r4, r5, rLink>;
84201024:	d8 4c       	rts;

84201026 <Lc_metadata_transport_with_ttp_reframe_1>:
/* Transport metadata from input to output, reframing output tags
 * to a fixed length to constrain the maximum packet size
 * This is required when using TWS with aptX input
 */
static void metadata_transport_with_ttp_reframe(RTP_DECODE_OP_DATA *opx_data, unsigned octets_copied)
{
84201026:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84201028:	11 09       	r7 = r0 + Null;
8420102a:	1a 09       	r8 = r1 + Null;
    metadata_tag *mtag_op, *mtag_ip, *mtag_ip_list = NULL;
8420102c:	40 de       	M[FP + 32] = Null;
    TIME base_toa, base_ttp;
    ttp_status status;

    patch_fn_shared(rtp_decode);

    if (buff_has_metadata(opx_data->ip_buffer))
8420102e:	92 f0 0d 88 	r0 = M[r7 + 52];
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (buff->metadata != NULL)
84201032:	91 89       	rMAC = M[r0 + 24];
84201034:	8a 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_26;

84201036 <Lc_metadata_transport_with_ttp_reframe_2>:
    {
        mtag_ip_list = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
84201036:	85 12       	r3 = FP + 40;
84201038:	44 12       	r2 = FP + 36;
8420103a:	ff fd 9c f0 	call (m) 0x149ca;
8420103e:	31 ec 
84201040:	42 de       	M[FP + 32] = r0;

84201042 <Lc_metadata_transport_with_ttp_reframe_3>:
    {
        b4idx = 0;
    }

    /* It's not worth doing anything if the output doesn't have metadata */
    if (buff_has_metadata(opx_data->op_buffer))
84201042:	91 f0 0e 88 	rMAC = M[r7 + 56];
84201046:	89 89       	rMAC = M[rMAC + 24];
84201048:	7b 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_25;

8420104a <Lc_metadata_transport_with_ttp_reframe_4>:
    {
        /* Find the first ToA tag */
        mtag_ip = mtag_ip_list;
8420104a:	46 d8       	r4 = M[FP + 32];

8420104c <Lc_metadata_transport_with_ttp_reframe_5>:
        while ((mtag_ip != NULL) && (!IS_TIME_OF_ARRIVAL_TAG(mtag_ip)))
8420104c:	30 04       	Null = r4 - Null;
8420104e:	35 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_13;

84201050 <Lc_metadata_transport_with_ttp_reframe_6>:
84201050:	71 88       	rMAC = M[r4 + 4];
84201052:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84201056:	10 f0 40 24 	Null = rMAC - 64;
8420105a:	07 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_8;

8420105c <Lc_metadata_transport_with_ttp_reframe_7>:
        {
            b4idx += mtag_ip->length;
8420105c:	f1 88       	rMAC = M[r4 + 12];
8420105e:	4a d8       	r0 = M[FP + 36];
84201060:	51 00       	rMAC = r0 + rMAC;
84201062:	49 de       	M[FP + 36] = rMAC;
            mtag_ip = mtag_ip->next;
84201064:	36 e8       	r4 = M[r4 + Null];
    /* It's not worth doing anything if the output doesn't have metadata */
    if (buff_has_metadata(opx_data->op_buffer))
    {
        /* Find the first ToA tag */
        mtag_ip = mtag_ip_list;
        while ((mtag_ip != NULL) && (!IS_TIME_OF_ARRIVAL_TAG(mtag_ip)))
84201066:	f3 6f       	jump (m) Lc_metadata_transport_with_ttp_reframe_5;

84201068 <Lc_metadata_transport_with_ttp_reframe_8>:
        {
            b4idx += mtag_ip->length;
            mtag_ip = mtag_ip->next;
        }

        if ((b4idx == 0) && (mtag_ip != NULL))
84201068:	48 d8       	Null = M[FP + 36];
8420106a:	27 62       	if NE jump (m) Lc_metadata_transport_with_ttp_reframe_13;

8420106c <Lc_metadata_transport_with_ttp_reframe_9>:
        {
            /* If the old tag is already at the start of the input data,
             * Just use its timestamp directly
             */
            base_toa = mtag_ip->timestamp;
8420106c:	33 89       	r1 = M[r4 + 16];

8420106e <Lc_metadata_transport_with_ttp_reframe_10>:
        }

        if (mtag_ip != NULL)
        {
            /* Save the timestamp info from the incoming metadata */
            opx_data->last_tag_timestamp = mtag_ip->timestamp;
8420106e:	31 89       	rMAC = M[r4 + 16];
84201070:	91 f0 16 8e 	M[r7 + 88] = rMAC;
            opx_data->last_toa_valid = TRUE;
84201074:	41 20       	rMAC = Null + 1;
84201076:	91 f0 17 8e 	M[r7 + 92] = rMAC;

8420107a <Lc_metadata_transport_with_ttp_reframe_11>:
        }

        ttp_update_ttp(opx_data->ttp_instance, base_toa, octets_copied, &status);
8420107a:	c5 12       	r3 = FP + 44;
8420107c:	92 f0 12 88 	r0 = M[r7 + 72];
84201080:	54 08       	r2 = r8 + Null;
84201082:	ff fd c2 f0 	call (m) 0x1962e;
84201086:	2d ed 
        base_ttp = status.ttp;
84201088:	eb f0 0b 88 	r9 = M[FP + 44];

        /* Distance to the first tag */
        out_tagged_octets = opx_data->max_packet_len - opx_data->last_op_tag_octets;
8420108c:	91 f0 15 88 	rMAC = M[r7 + 84];
84201090:	92 f0 18 88 	r0 = M[r7 + 96];
84201094:	8f 04       	r5 = rMAC - r0;

        if (out_tagged_octets >= octets_copied)
84201096:	af f7 00 c2 	Null = r5 - r8;
8420109a:	1c 64       	if NC jump (m) Lc_metadata_transport_with_ttp_reframe_17;

8420109c <Lc_metadata_transport_with_ttp_reframe_12>:
        {
            /* No new tag in this chunk of data */
            buff_metadata_append(opx_data->op_buffer, NULL, octets_copied, 0);
8420109c:	92 f0 0e 88 	r0 = M[r7 + 56];
842010a0:	05 00       	r3 = Null + Null;
842010a2:	03 00       	r1 = Null + Null;
842010a4:	54 08       	r2 = r8 + Null;
842010a6:	ff fd 9b f0 	call (m) 0x147b8;
842010aa:	33 e8 
            opx_data->last_op_tag_octets += octets_copied;
842010ac:	91 f0 18 88 	rMAC = M[r7 + 96];
842010b0:	51 0c       	rMAC = r8 + rMAC;
842010b2:	91 f0 18 8e 	M[r7 + 96] = rMAC;
842010b6:	44 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_25;

842010b8 <Lc_metadata_transport_with_ttp_reframe_13>:
            L3_DBG_MSG1("RTP reframe : tag at start, ToA = %d", base_toa);
        }
        else
        {
            /* Otherwise, use the previously-stashed timestamp if there is one */
            if (opx_data->last_toa_valid)
842010b8:	90 f0 17 88 	Null = M[r7 + 92];
842010bc:	04 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_15;

842010be <Lc_metadata_transport_with_ttp_reframe_14>:
            {
                base_toa = opx_data->last_tag_timestamp;
842010be:	93 f0 16 88 	r1 = M[r7 + 88];
842010c2:	05 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_16;

842010c4 <Lc_metadata_transport_with_ttp_reframe_15>:
                L3_DBG_MSG1("RTP reframe : old ToA = %d", base_toa);
            }
            else
            {
                /* Just use the current TIMER_TIME */
                base_toa = time_get_time();
842010c4:	ff fd 28 f0 	call (m) 0x6100;
842010c8:	3d e1 
842010ca:	13 00       	r1 = r0 + Null;

842010cc <Lc_metadata_transport_with_ttp_reframe_16>:
                L3_DBG_MSG1("RTP reframe : no tag, ToA = %d", base_toa);
            }
        }

        if (mtag_ip != NULL)
842010cc:	30 04       	Null = r4 - Null;
842010ce:	d0 63       	if NE jump (m) Lc_metadata_transport_with_ttp_reframe_10;

842010d0 <Lc__ite_16>:
842010d0:	d5 6f       	jump (m) Lc_metadata_transport_with_ttp_reframe_11;

842010d2 <Lc_metadata_transport_with_ttp_reframe_17>:
            buff_metadata_append(opx_data->op_buffer, NULL, octets_copied, 0);
            opx_data->last_op_tag_octets += octets_copied;
        }
        else
        {
            b4idx = out_tagged_octets;
842010d2:	4f de       	M[FP + 36] = r5;

842010d4 <Lc_metadata_transport_with_ttp_reframe_18>:

            /* Make a new list of tags for the output */
            while (out_tagged_octets < octets_copied)
            {
                mtag_op = buff_metadata_new_tag();
842010d4:	ff fd 9a f0 	call (m) 0x1454e;
842010d8:	3b e3 
842010da:	16 00       	r4 = r0 + Null;

                if (mtag_op != NULL)
842010dc:	17 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_20;

842010de <Lc_metadata_transport_with_ttp_reframe_19>:
                {
                    mtag_op->length = opx_data->max_packet_len;
842010de:	91 f0 15 88 	rMAC = M[r7 + 84];
842010e2:	f1 8e       	M[r4 + 12] = rMAC;
                    METADATA_PACKET_START_SET(mtag_op);
842010e4:	71 88       	rMAC = M[r4 + 4];
842010e6:	c9 c8       	rMAC = rMAC OR 0x4;
                    METADATA_PACKET_END_SET(mtag_op);
842010e8:	49 c9       	rMAC = rMAC OR 0x8;
842010ea:	71 8e       	M[r4 + 4] = rMAC;
                    status.ttp = ttp_get_next_timestamp(base_ttp, out_tagged_octets, opx_data->sample_rate, status.sp_adjustment);
842010ec:	65 d8       	r3 = M[FP + 48];
842010ee:	94 f0 14 88 	r2 = M[r7 + 80];
842010f2:	3b 00       	r1 = r5 + Null;
842010f4:	5a 08       	r0 = r9 + Null;
842010f6:	ff fd c5 f0 	call (m) 0x19b02;
842010fa:	2d e0 
842010fc:	5a de       	M[FP + 44] = r0;
                    ttp_utils_populate_tag(mtag_op, &status);
842010fe:	c3 12       	r1 = FP + 44;
84201100:	32 00       	r0 = r4 + Null;
84201102:	ef fd fd ff 	call (m) 0xbe6;
84201106:	25 e7 
                    L3_DBG_MSG5("RTP reframe tag, ToA = %d, base = %d, TTP = %d, len = %d, offset = %d", base_toa, base_ttp, status.ttp, mtag_op->length, out_tagged_octets);
                    /* Make sure only one tag gets the stream start flag */
                    status.stream_restart = FALSE;
84201108:	70 de       	M[FP + 56] = Null;

8420110a <Lc_metadata_transport_with_ttp_reframe_20>:
                }
                out_tagged_octets += opx_data->max_packet_len;
8420110a:	98 f0 15 88 	r6 = M[r7 + 84];
8420110e:	47 0c       	r5 = r6 + r5;
                if (out_tagged_octets > octets_copied)
84201110:	af f7 00 c2 	Null = r5 - r8;
84201114:	09 f0 8f e0 	if LS jump (m) Lc_metadata_transport_with_ttp_reframe_22;

84201118 <Lc_metadata_transport_with_ttp_reframe_21>:
                {
                    /* Partial tag, so constrain the append to the copied amount */
                    append_length = opx_data->max_packet_len - (out_tagged_octets - octets_copied);
84201118:	af f8 01 c0 	rMAC = r6 + r8;
8420111c:	7f f1 08 c2 	r6 = rMAC - r5;
84201120:	01 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_22;

84201122 <Lc_metadata_transport_with_ttp_reframe_22>:
                else
                {
                    append_length = opx_data->max_packet_len;
                }

                buff_metadata_append(opx_data->op_buffer, mtag_op, b4idx, append_length);
84201122:	4c d8       	r2 = M[FP + 36];
84201124:	92 f0 0e 88 	r0 = M[r7 + 56];
84201128:	45 08       	r3 = r6 + Null;
8420112a:	33 00       	r1 = r4 + Null;
8420112c:	ff fd 9b f0 	call (m) 0x147b8;
84201130:	2d e4 
                b4idx = 0;
84201132:	48 de       	M[FP + 36] = Null;
        else
        {
            b4idx = out_tagged_octets;

            /* Make a new list of tags for the output */
            while (out_tagged_octets < octets_copied)
84201134:	af f7 00 c2 	Null = r5 - r8;
84201138:	ce 65       	if NC jump (m) Lc_metadata_transport_with_ttp_reframe_18;

8420113a <Lc_metadata_transport_with_ttp_reframe_24>:
                }

                buff_metadata_append(opx_data->op_buffer, mtag_op, b4idx, append_length);
                b4idx = 0;
            }
            opx_data->last_op_tag_octets = append_length;
8420113a:	98 f0 18 8e 	M[r7 + 96] = r6;

8420113e <Lc_metadata_transport_with_ttp_reframe_25>:
        }
    }
    buff_metadata_tag_list_delete(mtag_ip_list);
8420113e:	42 d8       	r0 = M[FP + 32];
84201140:	ff fd 9a f0 	call (m) 0x145ee;
84201144:	2f e5 
84201146:	03 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_27;

84201148 <Lc_metadata_transport_with_ttp_reframe_26>:
    {
        mtag_ip_list = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
    }
    else
    {
        b4idx = 0;
84201148:	48 de       	M[FP + 36] = Null;
8420114a:	7c 6f       	jump (m) Lc_metadata_transport_with_ttp_reframe_3;

8420114c <Lc_metadata_transport_with_ttp_reframe_27>:
            }
            opx_data->last_op_tag_octets = append_length;
        }
    }
    buff_metadata_tag_list_delete(mtag_ip_list);
}
8420114c:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420114e:	d8 4c       	rts;

84201150 <Lc_metadata_transport_with_ttp_1>:
 * either adding time-to-play on existing tags or creating new ones if none are present
 * This is only used by the "TTP ONLY" mode with aptX, because it relies on
 * a known fixed compression ratio. This is not used in aptX HD
 */
static void metadata_transport_with_ttp(RTP_DECODE_OP_DATA *opx_data, unsigned octets_copied)
{
84201150:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84201152:	11 09       	r7 = r0 + Null;
84201154:	1e 00       	r4 = r1 + Null;
    metadata_tag *mtag = NULL;
    unsigned b4idx, afteridx;
    tCbuffer *buffer;

    patch_fn_shared(rtp_decode);
    PL_ASSERT(opx_data->codec_type == APTX);
84201156:	91 f0 11 80 	rMAC = MBS[r7 + 17];
8420115a:	08 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_3;

8420115c <Lc_metadata_transport_with_ttp_2>:
8420115c:	03 f0 81 48 	r1 = Null + 1153;
84201160:	02 f0 13 60 	r0 = Null + 4115;
84201164:	ff fd af f0 	call (m) 0x16ff0;
84201168:	2d e4 

8420116a <Lc_metadata_transport_with_ttp_3>:

    if (opx_data->max_packet_len != 0)
8420116a:	90 f0 15 88 	Null = M[r7 + 84];
8420116e:	03 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_5;

84201170 <Lc_metadata_transport_with_ttp_4>:
    {
        metadata_transport_with_ttp_reframe(opx_data, octets_copied);
84201170:	5b 4f       	call (m) Lc_metadata_transport_with_ttp_reframe_1;
        return;
84201172:	69 6e       	jump (m) Lc_metadata_transport_with_ttp_21;

84201174 <Lc_metadata_transport_with_ttp_5>:
    }

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84201174:	90 f0 1a 88 	Null = M[r7 + 104];
84201178:	04 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_7;

8420117a <Lc_metadata_transport_with_ttp_6>:
    {
        buffer = opx_data->u.pack.internal_buffer;
8420117a:	9a f0 11 88 	r8 = M[r7 + 68];
8420117e:	03 6e       	jump (m) Lc_metadata_transport_with_ttp_8;

84201180 <Lc_metadata_transport_with_ttp_7>:
    }
    else
    {
        buffer = opx_data->op_buffer;
84201180:	9a f0 0e 88 	r8 = M[r7 + 56];

84201184 <Lc_metadata_transport_with_ttp_8>:
    }

    if (buff_has_metadata(opx_data->ip_buffer))
84201184:	92 f0 0d 88 	r0 = M[r7 + 52];
84201188:	91 89       	rMAC = M[r0 + 24];
8420118a:	13 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_12;

8420118c <Lc_metadata_transport_with_ttp_9>:
    {
        /* transport metadata, first (attempt to) consume tag associated with src */
        mtag = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
8420118c:	05 12       	r3 = FP + 32;
8420118e:	c4 11       	r2 = FP + 28;
84201190:	ff fd 9c f0 	call (m) 0x149ca;
84201194:	3b e1 
84201196:	10 09       	r6 = r0 + Null;
        {
            mtag->length = octets_copied;
        }
    }

    if (mtag != NULL)
84201198:	15 62       	if NE jump (m) Lc_metadata_transport_with_ttp_14;

8420119a <Lc_metadata_transport_with_ttp_10>:
8420119a:	a1 f0 06 88 	rMAC = M[r8 + 24];
8420119e:	4f 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_20;

842011a0 <Lc_metadata_transport_with_ttp_11>:
        }
    }

    if (buff_has_metadata(buffer))
    {
        buff_metadata_append(buffer, mtag, b4idx, afteridx);
842011a0:	45 d8       	r3 = M[FP + 32];
842011a2:	3c d8       	r2 = M[FP + 28];
842011a4:	43 08       	r1 = r6 + Null;
842011a6:	52 08       	r0 = r8 + Null;
842011a8:	ff fd 9b f0 	call (m) 0x147b8;
842011ac:	31 e0 
842011ae:	4b 6e       	jump (m) Lc_metadata_transport_with_ttp_21;

842011b0 <Lc_metadata_transport_with_ttp_12>:
        mtag = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
    }
    else
    {
        /* Create a new tag for the output */
        b4idx = 0;
842011b0:	38 de       	M[FP + 28] = Null;
        afteridx = octets_copied;
842011b2:	46 de       	M[FP + 32] = r4;
        mtag = buff_metadata_new_tag();
842011b4:	ff fd 99 f0 	call (m) 0x1454e;
842011b8:	3b ec 
842011ba:	10 09       	r6 = r0 + Null;
        if (mtag != NULL)
842011bc:	ef 61       	if EQ jump (m) Lc_metadata_transport_with_ttp_10;

842011be <Lc_metadata_transport_with_ttp_13>:
        {
            mtag->length = octets_copied;
842011be:	86 f0 03 8e 	M[r6 + 12] = r4;

842011c2 <Lc_metadata_transport_with_ttp_14>:
    }

    if (mtag != NULL)
    {
        ttp_status status;
        metadata_tag *list_tag = mtag->next;
842011c2:	87 f0 00 e8 	r5 = M[r6 + Null];
        unsigned list_samples = mtag->length;
842011c6:	86 f0 03 88 	r4 = M[r6 + 12];
        unsigned time_of_arrival;

        time_of_arrival = get_time_of_arrival(mtag);
842011ca:	fd ff 21 ee 	call (m) Lc_get_time_of_arrival_1;
842011ce:	13 00       	r1 = r0 + Null;
        /* the tag will be reused for timestamp, so unset the time of arrival flag. */
        METADATA_TIME_OF_ARRIVAL_UNSET(mtag);
842011d0:	81 f0 01 88 	rMAC = M[r6 + 4];
842011d4:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
842011d8:	81 f0 01 8e 	M[r6 + 4] = rMAC;

842011dc <Lc_metadata_transport_with_ttp_15>:

        /* Calculate the total tags length. to avoid losing data when no tags are read
         * from the input buffer. */
        while (list_tag != NULL)
842011dc:	38 04       	Null = r5 - Null;
842011de:	09 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_17;

842011e0 <Lc_metadata_transport_with_ttp_16>:
        {
            METADATA_TIME_OF_ARRIVAL_UNSET(list_tag);
842011e0:	79 88       	rMAC = M[r5 + 4];
842011e2:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
842011e6:	79 8e       	M[r5 + 4] = rMAC;
            list_samples += list_tag->length;
842011e8:	f9 88       	rMAC = M[r5 + 12];
842011ea:	8e 01       	r4 = rMAC + r4;
            list_tag = list_tag->next;
842011ec:	3f e8       	r5 = M[r5 + Null];
        /* the tag will be reused for timestamp, so unset the time of arrival flag. */
        METADATA_TIME_OF_ARRIVAL_UNSET(mtag);

        /* Calculate the total tags length. to avoid losing data when no tags are read
         * from the input buffer. */
        while (list_tag != NULL)
842011ee:	f7 6f       	jump (m) Lc_metadata_transport_with_ttp_15;

842011f0 <Lc_metadata_transport_with_ttp_17>:
        }

        /* For aptX, each stereo pair of samples is encoded as one octet
         * This means the sample count for TTP is the same as the number of encoded octets
         */
        ttp_update_ttp(opx_data->ttp_instance, time_of_arrival, list_samples, &status);
842011f0:	45 12       	r3 = FP + 36;
842011f2:	92 f0 12 88 	r0 = M[r7 + 72];
842011f6:	34 00       	r2 = r4 + Null;
842011f8:	ff fd c2 f0 	call (m) 0x1962e;
842011fc:	37 e1 

        /* Populate the metadata tag from the TTP status */
        ttp_utils_populate_tag(mtag, &status);
842011fe:	43 12       	r1 = FP + 36;
84201200:	42 08       	r0 = r6 + Null;
84201202:	ef fd fc ff 	call (m) 0xbe6;
84201206:	25 ef 

        /* Make sure only one tag gets the stream start flag */
        status.stream_restart = FALSE;
84201208:	60 de       	M[FP + 48] = Null;

        /* In case there were multiple metadata tags on the input,
         * extrapolate the timestamps to any subsequent tags
         */
        list_tag = mtag->next;
8420120a:	86 f0 00 e8 	r4 = M[r6 + Null];
        list_samples = mtag->length;
8420120e:	87 f0 03 88 	r5 = M[r6 + 12];

84201212 <Lc_metadata_transport_with_ttp_18>:
        while (list_tag != NULL)
84201212:	30 04       	Null = r4 - Null;
84201214:	c3 61       	if EQ jump (m) Lc_metadata_transport_with_ttp_10;

84201216 <Lc_metadata_transport_with_ttp_19>:
        {
            status.ttp = ttp_get_next_timestamp(mtag->timestamp, list_samples, opx_data->sample_rate, status.sp_adjustment);
84201216:	55 d8       	r3 = M[FP + 40];
84201218:	94 f0 14 88 	r2 = M[r7 + 80];
8420121c:	82 f0 04 88 	r0 = M[r6 + 16];
84201220:	3b 00       	r1 = r5 + Null;
84201222:	ff fd c4 f0 	call (m) 0x19b02;
84201226:	21 e7 
84201228:	4a de       	M[FP + 36] = r0;
            ttp_utils_populate_tag(list_tag, &status);
8420122a:	43 12       	r1 = FP + 36;
8420122c:	32 00       	r0 = r4 + Null;
8420122e:	ef fd fc ff 	call (m) 0xbe6;
84201232:	39 ed 
            list_samples += list_tag->length;
84201234:	f1 88       	rMAC = M[r4 + 12];
84201236:	cf 01       	r5 = rMAC + r5;
            list_tag = list_tag->next;
84201238:	36 e8       	r4 = M[r4 + Null];
        /* In case there were multiple metadata tags on the input,
         * extrapolate the timestamps to any subsequent tags
         */
        list_tag = mtag->next;
        list_samples = mtag->length;
        while (list_tag != NULL)
8420123a:	ec 6f       	jump (m) Lc_metadata_transport_with_ttp_18;

8420123c <Lc_metadata_transport_with_ttp_20>:
    {
        buff_metadata_append(buffer, mtag, b4idx, afteridx);
    }
    else
    {
        buff_metadata_tag_list_delete(mtag);
8420123c:	42 08       	r0 = r6 + Null;
8420123e:	ff fd 99 f0 	call (m) 0x145ee;
84201242:	31 ed 

84201244 <Lc_metadata_transport_with_ttp_21>:
    }

}
84201244:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84201246:	d8 4c       	rts;

84201248 <Lc_rtp_decode_empty_internal_buffers_1>:
/**
 * Function which tries to empty the internal buffers of the RTP decode
 * by copying to output.
 */
static void rtp_decode_empty_internal_buffers(RTP_DECODE_OP_DATA *opx_data,TOUCHED_TERMINALS *touched)
{
84201248:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420124a:	16 00       	r4 = r0 + Null;
8420124c:	1f 00       	r5 = r1 + Null;
    unsigned data;
    if (!opx_data->pack_latency_buffer)
8420124e:	b0 b8       	Null = M[r4 + 104];
84201250:	25 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_6;

84201252 <Lc_rtp_decode_empty_internal_buffers_2>:
    {
        return;
    }
    data = buff_metadata_available_octets(opx_data->u.pack.frame_buffer);
84201252:	32 a8       	r0 = M[r4 + 64];
84201254:	ff fd 9b f0 	call (m) 0x14958;
84201258:	25 e8 
8420125a:	14 00       	r2 = r0 + Null;
    if (data > 0)
8420125c:	0c 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_4;

8420125e <Lc_rtp_decode_empty_internal_buffers_3>:
    {
        data = cbuffer_copy_ex(opx_data->u.pack.internal_buffer, opx_data->u.pack.frame_buffer, data);
8420125e:	33 a8       	r1 = M[r4 + 64];
84201260:	72 a8       	r0 = M[r4 + 68];
84201262:	ff fd 59 f1 	call (m) 0x2c4ec;
84201266:	2b e4 
84201268:	14 00       	r2 = r0 + Null;
        metadata_strict_transport(opx_data->u.pack.frame_buffer, opx_data->u.pack.internal_buffer, data);
8420126a:	73 a8       	r1 = M[r4 + 68];
8420126c:	32 a8       	r0 = M[r4 + 64];
8420126e:	ff fd 9d f0 	call (m) 0x14c88;
84201272:	3b e0 

84201274 <Lc_rtp_decode_empty_internal_buffers_4>:
    }
    data = buff_metadata_available_octets(opx_data->u.pack.internal_buffer);
84201274:	72 a8       	r0 = M[r4 + 68];
84201276:	ff fd 9b f0 	call (m) 0x14958;
8420127a:	23 e7 
8420127c:	14 00       	r2 = r0 + Null;
    if (data > 0)
8420127e:	0e 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_6;

84201280 <Lc_rtp_decode_empty_internal_buffers_5>:
    {

        data = cbuffer_copy_ex(opx_data->op_buffer, opx_data->u.pack.internal_buffer, data);
84201280:	73 a8       	r1 = M[r4 + 68];
84201282:	b2 99       	r0 = M[r4 + 56];
84201284:	ff fd 59 f1 	call (m) 0x2c4ec;
84201288:	29 e3 
8420128a:	14 00       	r2 = r0 + Null;
        metadata_strict_transport(opx_data->u.pack.internal_buffer, opx_data->op_buffer, data);
8420128c:	b3 99       	r1 = M[r4 + 56];
8420128e:	72 a8       	r0 = M[r4 + 68];
84201290:	ff fd 9c f0 	call (m) 0x14c88;
84201294:	39 ef 
        /* Kick forward if there was any valid frames in the RTP packet. */
        touched->sources = TOUCHED_SOURCE_0;
84201296:	41 20       	rMAC = Null + 1;
84201298:	39 ee       	M[r5 + Null] = rMAC;

8420129a <Lc_rtp_decode_empty_internal_buffers_6>:
    }
}
8420129a:	f2 48       	popm <FP, r4, r5, rLink>;
8420129c:	d8 4c       	rts;

8420129e <$_get_samples_in_packet>:
8420129e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
        frame_data->total_encoded_data = (uint16)offset;
    }
}

void get_samples_in_packet(RTP_DECODE_OP_DATA *opx_data, RTP_FRAME_DECODE_DATA* frame_data)
{
842012a0:	17 00       	r5 = r0 + Null;
842012a2:	1e 00       	r4 = r1 + Null;
    tCbuffer *clone_buffer;
    unsigned payload_size;

    patch_fn_shared(rtp_decode);
    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
842012a4:	b8 b8       	Null = M[r5 + 104];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
842012a6:	fa 99       	r0 = M[r5 + 60];
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
    }

    payload_size = cbuffer_calc_amount_data_ex(clone_buffer);
842012a8:	ff fd dc f1 	call (m) 0x3cad6;
842012ac:	2f e1 
    frame_data->valid = FALSE;
842012ae:	30 ee       	M[r4 + Null] = Null;

    switch (opx_data->codec_type)
842012b0:	79 a0       	rMAC = MBS[r5 + 17];
842012b2:	1e 60       	if EQ jump (m) Lc_get_samples_in_packet_11;

842012b4 <Lc_get_samples_in_packet_2>:
842012b4:	48 24       	Null = rMAC - 1;
842012b6:	17 60       	if EQ jump (m) Lc_get_samples_in_packet_10;

842012b8 <Lc_get_samples_in_packet_3>:
842012b8:	88 24       	Null = rMAC - 2;
842012ba:	35 68       	if LT jump (m) Lc_get_samples_in_packet_17;

842012bc <Lc_get_samples_in_packet_4>:
842012bc:	c8 24       	Null = rMAC - 3;
842012be:	38 6c       	if LE jump (m) Lc_get_samples_in_packet_18;

842012c0 <Lc_get_samples_in_packet_5>:
842012c0:	08 25       	Null = rMAC - 4;
842012c2:	06 62       	if NE jump (m) Lc_get_samples_in_packet_7;

842012c4 <Lc_get_samples_in_packet_6>:
            frame_data->nr_of_frames = 1;
            break;
        }
        case AAC:
        {
            aac_sample_count(opx_data, payload_size, frame_data);
842012c4:	34 00       	r2 = r4 + Null;
842012c6:	13 00       	r1 = r0 + Null;
842012c8:	3a 00       	r0 = r5 + Null;
842012ca:	34 4e       	call (m) Lc_aac_sample_count_1;
            break;
842012cc:	31 6e       	jump (m) Lc_get_samples_in_packet_18;

842012ce <Lc_get_samples_in_packet_7>:
    }

    payload_size = cbuffer_calc_amount_data_ex(clone_buffer);
    frame_data->valid = FALSE;

    switch (opx_data->codec_type)
842012ce:	48 25       	Null = rMAC - 5;
842012d0:	1a 60       	if EQ jump (m) Lc_get_samples_in_packet_14;

842012d2 <Lc_get_samples_in_packet_8>:
842012d2:	88 25       	Null = rMAC - 6;
842012d4:	28 62       	if NE jump (m) Lc_get_samples_in_packet_17;

842012d6 <Lc_get_samples_in_packet_9>:
            }
            break;
        }
        case APTXADAPTIVE:
        {
            frame_data->valid = TRUE;
842012d6:	41 20       	rMAC = Null + 1;
842012d8:	31 ee       	M[r4 + Null] = rMAC;
            /* Extract the number of samples from the RTP Timestamp */
            frame_data->frame_samples = RTP_TIMESTAMP_APTX_AD_GET_SAMPLES(frame_data->rtp_timestamp);
842012da:	31 89       	rMAC = M[r4 + 16];
842012dc:	89 c6       	rMAC = rMAC AND 0xffff;
842012de:	b1 8e       	M[r4 + 8] = rMAC;
            frame_data->frame_length = payload_size;
842012e0:	72 8e       	M[r4 + 4] = r0;
842012e2:	1e 6e       	jump (m) Lc_get_samples_in_packet_16;

842012e4 <Lc_get_samples_in_packet_10>:

    switch (opx_data->codec_type)
    {
        case SBC:
        {
            sbc_sample_count(opx_data, payload_size, frame_data);
842012e4:	34 00       	r2 = r4 + Null;
842012e6:	13 00       	r1 = r0 + Null;
842012e8:	3a 00       	r0 = r5 + Null;
842012ea:	43 4e       	call (m) Lc_sbc_sample_count_1;
            break;
842012ec:	21 6e       	jump (m) Lc_get_samples_in_packet_18;

842012ee <Lc_get_samples_in_packet_11>:
        {
            break;
        }
        case APTX:
        {
            frame_data->valid = TRUE;
842012ee:	41 20       	rMAC = Null + 1;
842012f0:	31 ee       	M[r4 + Null] = rMAC;
            /* For aptX, the generated samples is the same as the number of encoded octets,
             * as long as the input number of octets is a multiple of 4.
             * This is assumed to always be the case here. */
            payload_size = payload_size >> 2;
842012f2:	52 50       	r0 = r0 LSHIFT -2;
            payload_size = payload_size << 2;
            if (payload_size != 0)
842012f4:	52 54       	r0 = r0 LSHIFT 2;
842012f6:	05 60       	if EQ jump (m) Lc_get_samples_in_packet_13;

842012f8 <Lc_get_samples_in_packet_12>:
            {
                frame_data->frame_length = payload_size;
842012f8:	72 8e       	M[r4 + 4] = r0;
                frame_data->nr_of_frames = 1;
842012fa:	f1 8e       	M[r4 + 12] = rMAC;
                frame_data->frame_samples = payload_size;
842012fc:	b2 8e       	M[r4 + 8] = r0;
842012fe:	18 6e       	jump (m) Lc_get_samples_in_packet_18;

84201300 <Lc_get_samples_in_packet_13>:
            }
            else
            {
                L4_DBG_MSG("RTP decode APTX classic: Not enough data to create a tag.");
                frame_data->nr_of_frames = 0;
84201300:	f0 8e       	M[r4 + 12] = Null;
84201302:	16 6e       	jump (m) Lc_get_samples_in_packet_18;

84201304 <Lc_get_samples_in_packet_14>:
            }
            break;
        }
        case APTXHD:
        {
            frame_data->valid = TRUE;
84201304:	41 20       	rMAC = Null + 1;
84201306:	31 ee       	M[r4 + Null] = rMAC;
            /* For aptXHD, every 6 input octets generates 4 output samples. */
            frame_data->frame_samples = payload_size / 3;
84201308:	c3 20       	r1 = Null + 3;
8420130a:	ff fd c7 f0 	call (m) 0x1a290;
8420130e:	27 ec 
            frame_data->frame_samples >>= 1;
84201310:	12 50       	r0 = r0 LSHIFT -1;
            if (frame_data->frame_samples != 0)
84201312:	b2 8e       	M[r4 + 8] = r0;
84201314:	f6 61       	if EQ jump (m) Lc_get_samples_in_packet_13;

84201316 <Lc_get_samples_in_packet_15>:
            {
                frame_data->frame_length = frame_data->frame_samples * 6;
84201316:	91 41       	rMAC = r0 * 6 (int);
84201318:	71 8e       	M[r4 + 4] = rMAC;
                frame_data->frame_samples <<= 2;
8420131a:	52 54       	r0 = r0 LSHIFT 2;
8420131c:	b2 8e       	M[r4 + 8] = r0;

8420131e <Lc_get_samples_in_packet_16>:
        {
            frame_data->valid = TRUE;
            /* Extract the number of samples from the RTP Timestamp */
            frame_data->frame_samples = RTP_TIMESTAMP_APTX_AD_GET_SAMPLES(frame_data->rtp_timestamp);
            frame_data->frame_length = payload_size;
            frame_data->nr_of_frames = 1;
8420131e:	41 20       	rMAC = Null + 1;
84201320:	f1 8e       	M[r4 + 12] = rMAC;
84201322:	06 6e       	jump (m) Lc_get_samples_in_packet_18;

84201324 <Lc_get_samples_in_packet_17>:
            break;
        }
        default:
        {
            /*mode not supported yet*/
            panic(PANIC_AUDIO_RTP_UNSUPPORTED_CODEC);
84201324:	02 f0 7a 40 	r0 = Null + 122;
84201328:	ff fd ae f0 	call (m) 0x16fe6;
8420132c:	3f e5 

8420132e <Lc_get_samples_in_packet_18>:
            break;
        }
    }
}
8420132e:	f2 48       	popm <FP, r4, r5, rLink>;
84201330:	d8 4c       	rts;

84201332 <Lc_aac_sample_count_1>:
 * \param payload_size Pointer to the RTP operator data.
 * \param frame_data Pointer to the frame data structure.
 */
static void aac_sample_count(RTP_DECODE_OP_DATA *opx_data, unsigned payload_size,
        RTP_FRAME_DECODE_DATA *frame_decode_data)
{
84201332:	c8 1e       	pushm <FP(=SP), rLink>, SP = SP + 0x20;
    tCbuffer *clone_buffer;
    aac_codec *aac_codec_struc = (aac_codec *)opx_data->aac_codec;
84201334:	55 89       	r3 = M[r0 + 20];
    dummy_decoder aac_decoder;

    patch_fn_shared(rtp_decode);

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84201336:	90 b8       	Null = M[r0 + 104];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84201338:	d1 99       	rMAC = M[r0 + 60];
    }


    /* Initialise the input parameters for the codec.*/
    /* Set the  main decoder's structure.*/
    aac_decoder.aac_decoder_struc = aac_codec_struc;
8420133a:	15 de       	M[FP + 8] = r3;
    /* Set the return structure. */
    aac_decoder.frame_dec_struc = frame_decode_data;
8420133c:	2c de       	M[FP + 20] = r2;

    /* Set the payload size which is all the available data. */
    aac_decoder.payload_size = payload_size;
8420133e:	23 de       	M[FP + 16] = r1;

    /* Set the input buffer. */
    aac_decoder.in_cbuffer = clone_buffer;
84201340:	19 de       	M[FP + 12] = rMAC;

#ifdef DATAFORMAT_32
    unsigned int offset = ((uintptr_t)(clone_buffer->read_ptr)) & 0x3;
84201342:	49 88       	rMAC = M[rMAC + 4];
    /* Set the bit position. */
    switch(offset)
84201344:	89 c0       	rMAC = rMAC AND 0x3;
84201346:	06 60       	if EQ jump (m) Lc_aac_sample_count_4;

84201348 <Lc_aac_sample_count_2>:
84201348:	48 24       	Null = rMAC - 1;
8420134a:	07 62       	if NE jump (m) Lc_aac_sample_count_5;

8420134c <Lc_aac_sample_count_3>:
	{
	case 0:
        aac_decoder.bit_position = 32;
	    break;
	case 1:
        aac_decoder.bit_position = 24;
8420134c:	01 2a       	rMAC = Null + 24;
8420134e:	31 de       	M[FP + 24] = rMAC;
	    break;
84201350:	0a 6e       	jump (m) Lc_aac_sample_count_6;

84201352 <Lc_aac_sample_count_4>:
    unsigned int offset = ((uintptr_t)(clone_buffer->read_ptr)) & 0x3;
    /* Set the bit position. */
    switch(offset)
	{
	case 0:
        aac_decoder.bit_position = 32;
84201352:	01 30       	rMAC = Null + 32;
84201354:	31 de       	M[FP + 24] = rMAC;
	    break;
84201356:	07 6e       	jump (m) Lc_aac_sample_count_6;

84201358 <Lc_aac_sample_count_5>:
	case 1:
        aac_decoder.bit_position = 24;
	    break;
	case 2:
        aac_decoder.bit_position = 16;
84201358:	02 28       	r0 = Null + 16;
8420135a:	03 22       	r1 = Null + 8;
8420135c:	88 24       	Null = rMAC - 2;
8420135e:	00 f2 03 c0 	if EQ r1 = r0 + Null;
84201362:	33 de       	M[FP + 24] = r1;

84201364 <Lc_aac_sample_count_6>:
    {
        /* First octet from the word. */
        aac_decoder.bit_position = 16;
    }
#endif
    aacdec_samples_in_packet_lc(&aac_decoder);
84201364:	82 10       	r0 = FP + 8;
84201366:	ff fd b8 f3 	call 0x78424;
8420136a:	3e e5 

8420136c <Lc_aac_sample_count_7>:
}
8420136c:	c8 4a       	SP = SP - 0x20, popm <FP, rLink>;
8420136e:	d8 4c       	rts;

84201370 <Lc_sbc_sample_count_1>:
 * \param payload_size Pointer to the RTP operator data.
 * \param frame_data Pointer to the frame data structure.
 */
static void sbc_sample_count(RTP_DECODE_OP_DATA* opx_data, unsigned payload_size,
        RTP_FRAME_DECODE_DATA* frame_data)
{
84201370:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201372:	23 09       	r9 = r2 + Null;
    unsigned sbc_header[SBC_SAMPLE_COUNT_HEADER_SIZE];

    patch_fn_shared(rtp_decode);

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84201374:	90 b8       	Null = M[r0 + 104];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84201376:	d1 99       	rMAC = M[r0 + 60];
84201378:	41 de       	M[FP + 32] = rMAC;
    {
        clone_buffer = opx_data->u.clone_op_buffer;
    }

    unsigned mode;
    unsigned nrof_blocks = 0;
8420137a:	00 09       	r6 = Null + Null;
    unsigned nrof_subbands = 0;
8420137c:	01 09       	r7 = Null + Null;
    unsigned bitpool;
    unsigned offset = 0;
8420137e:	06 00       	r4 = Null + Null;
    unsigned sbc_frames_in_payload;
    unsigned payload_left = payload_size;
84201380:	1a 09       	r8 = r1 + Null;

    for (sbc_frames_in_payload = 0; sbc_frames_in_payload < frame_data->nr_of_frames_rtp_header; sbc_frames_in_payload++)
84201382:	07 00       	r5 = Null + Null;
84201384:	14 6e       	jump (m) Lc_sbc_sample_count_5;

84201386 <Lc_sbc_sample_count_2>:
                case SBC_HEADER1_CHANNEL_STEREO:
                {
                    /* nrof_channels = 2;
                     * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * bitpool) / 8); */
                    frame_length = 4 + nrof_subbands
                            + ((nrof_blocks * bitpool) + 7) / 8;
84201386:	8f f2 81 c9 	rMAC = r0 * r6 (int);
8420138a:	ca 21       	r0 = rMAC + 7;
8420138c:	92 50       	r0 = r0 LSHIFT -3;
8420138e:	9f f2 01 c0 	rMAC = r0 + r7;
84201392:	09 21       	rMAC = rMAC + 4;

84201394 <Lc_sbc_sample_count_3>:
                default:
                {
                    break;
                }
            }
            if (frame_length <= payload_left)
84201394:	af f1 00 c2 	Null = rMAC - r8;
84201398:	08 f0 99 e1 	if HI jump (m) Lc_sbc_sample_count_14;

8420139c <Lc_sbc_sample_count_4>:
            {
                frame_data->frame_length_extra[sbc_frames_in_payload] = (uint16)frame_length;
8420139c:	b2 f0 06 88 	r0 = M[r9 + 24];
842013a0:	3b 54       	r1 = r5 LSHIFT 1;
842013a2:	d1 ec       	MH[r0 + r1] = rMAC;
                payload_left -= frame_length;
842013a4:	00 f1 3a c2 	r8 = r8 - rMAC;
                offset += frame_length;
842013a8:	8e 01       	r4 = rMAC + r4;
    unsigned bitpool;
    unsigned offset = 0;
    unsigned sbc_frames_in_payload;
    unsigned payload_left = payload_size;

    for (sbc_frames_in_payload = 0; sbc_frames_in_payload < frame_data->nr_of_frames_rtp_header; sbc_frames_in_payload++)
842013aa:	7f 20       	r5 = r5 + 1;

842013ac <Lc_sbc_sample_count_5>:
842013ac:	b1 f0 0a 86 	rMAC = MHU[r9 + 20];
842013b0:	78 04       	Null = r5 - rMAC;
842013b2:	02 f0 81 e1 	if C jump (m) Lc_sbc_sample_count_15;

842013b6 <Lc_sbc_sample_count_6>:
    {
        unsigned frame_length = 0;
        /* Read and unpack the sbc header. */
        unpack_cbuff_to_array_from_offset((int*) &sbc_header, clone_buffer,
                offset, SBC_SAMPLE_COUNT_HEADER_SIZE);
842013b6:	c5 20       	r3 = Null + 3;
842013b8:	42 12       	r0 = FP + 36;
842013ba:	34 00       	r2 = r4 + Null;
842013bc:	43 d8       	r1 = M[FP + 32];
842013be:	6d 4e       	call (m) $_unpack_cbuff_to_array_from_offset;

        mode = sbc_header[1] & SBC_HEADER1_CHANNEL_MASK;
842013c0:	52 d8       	r0 = M[FP + 40];
842013c2:	21 f0 0c 00 	rMAC = r0 AND 0xc;
        nrof_blocks = SBC_HEADER1_GET_NROF_BLOCKS(sbc_header[1]);
842013c6:	d3 50       	r1 = r0 LSHIFT -4;
842013c8:	9b c0       	r1 = r1 AND 0x3;
842013ca:	5b 20       	r1 = r1 + 1;
842013cc:	01 f3 d8 c8 	r6 = r1 LSHIFT 2;
        nrof_subbands = SBC_HEADER1_GET_NROF_SUBBANDS(sbc_header[1]);
842013d0:	12 c0       	r0 = r0 AND 0x1;
842013d2:	52 20       	r0 = r0 + 1;
842013d4:	01 f2 d9 c8 	r7 = r0 LSHIFT 2;
        bitpool = SBC_HEADER2_BITPOOL(sbc_header[2]);
842013d8:	5a d8       	r0 = M[FP + 44];
842013da:	92 c3       	r0 = r0 AND 0xff;

        if (sbc_header[0] == SBC_HEADER0_SYNC)
842013dc:	4b d8       	r1 = M[FP + 36];
842013de:	30 f0 9c 24 	Null = r1 - 156;
842013e2:	22 62       	if NE jump (m) Lc_sbc_sample_count_13;

842013e4 <Lc_sbc_sample_count_7>:
        {

            switch (mode)
842013e4:	08 04       	Null = rMAC - Null;
842013e6:	0e 60       	if EQ jump (m) Lc_sbc_sample_count_11;

842013e8 <Lc_sbc_sample_count_8>:
842013e8:	08 25       	Null = rMAC - 4;
842013ea:	15 60       	if EQ jump (m) Lc_sbc_sample_count_12;

842013ec <Lc_sbc_sample_count_9>:
842013ec:	08 26       	Null = rMAC - 8;
842013ee:	cc 61       	if EQ jump (m) Lc_sbc_sample_count_2;

842013f0 <Lc_sbc_sample_count_10>:
                case SBC_HEADER1_CHANNEL_JOINT:
                {
                    /* nrof_channels = 2;
                     * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_subbands + nrof_blocks *  bitpool)) / 8); */
                    frame_length = 4 + nrof_subbands
                            + ((nrof_subbands + nrof_blocks * bitpool) + 7) / 8;
842013f0:	8f f2 81 c9 	rMAC = r0 * r6 (int);
842013f4:	49 0c       	rMAC = r7 + rMAC;
842013f6:	ca 21       	r0 = rMAC + 7;
842013f8:	92 50       	r0 = r0 LSHIFT -3;
842013fa:	9f f2 01 c0 	rMAC = r0 + r7;
842013fe:	09 21       	rMAC = rMAC + 4;
                    break;
84201400:	ca 6f       	jump (m) Lc_sbc_sample_count_3;

84201402 <Lc_sbc_sample_count_11>:
                case SBC_HEADER1_CHANNEL_MONO:
                {
                    /* nrof_channels = 1;
                     * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * nrof_channels * bitpool) / 8); */
                    frame_length = 4 + (nrof_subbands) / 2
                            + ((nrof_blocks * bitpool) + 7) / 8;
84201402:	8f f2 81 c9 	rMAC = r0 * r6 (int);
84201406:	7f f9 d3 d8 	r1 = r7 LSHIFT -1;
8420140a:	ca 21       	r0 = rMAC + 7;
8420140c:	92 50       	r0 = r0 LSHIFT -3;
8420140e:	d1 00       	rMAC = r0 + r1;
84201410:	09 21       	rMAC = rMAC + 4;
                    break;
84201412:	c1 6f       	jump (m) Lc_sbc_sample_count_3;

84201414 <Lc_sbc_sample_count_12>:
                case SBC_HEADER1_CHANNEL_DUAL:
                {
                    /* nrof_channels = 2;
                     * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * nrof_channels * bitpool) / 8); */
                    frame_length = 4 + nrof_subbands
                            + ((nrof_blocks * 2 * bitpool) + 7) / 8;
84201414:	00 f8 d3 d8 	r1 = r6 LSHIFT 1;
84201418:	99 1a       	rMAC = r1 * r0 (int);
8420141a:	ca 21       	r0 = rMAC + 7;
8420141c:	92 50       	r0 = r0 LSHIFT -3;
8420141e:	9f f2 01 c0 	rMAC = r0 + r7;
84201422:	09 21       	rMAC = rMAC + 4;
                    break;
84201424:	b8 6f       	jump (m) Lc_sbc_sample_count_3;

84201426 <Lc_sbc_sample_count_13>:
                break;
            }
        }
        else
        {
            fault_diatribe(FAULT_RTP_SBC_SYNC_LOST, sbc_header[0]);
84201426:	02 f0 4c 40 	r0 = Null + 76;
8420142a:	ff fd ac f0 	call (m) 0x16ca6;
8420142e:	3d e3 

84201430 <Lc_sbc_sample_count_14>:
            }
            else
            {
                /* Probably the frame length calculation is wrong or the
                 * current frame_length exceeds the amount of payload left. */
                sbc_frames_in_payload = 0;
84201430:	07 00       	r5 = Null + Null;

84201432 <Lc_sbc_sample_count_15>:
            sbc_frames_in_payload = 0;
            break;
        }
    }

    if (payload_left == 0)
84201432:	0f fa 00 c2 	Null = r8 - Null;
84201436:	0c 62       	if NE jump (m) Lc_sbc_sample_count_17;

84201438 <Lc_sbc_sample_count_16>:
    {
        frame_data->valid = TRUE;
84201438:	41 20       	rMAC = Null + 1;
8420143a:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
        frame_data->nr_of_frames = sbc_frames_in_payload;
8420143e:	b7 f0 03 8e 	M[r9 + 12] = r5;
        /* frame_samples =  nrof_subbands * nrof_blocks. */
        frame_data->frame_samples = nrof_subbands * nrof_blocks;
84201442:	8f f9 81 c9 	rMAC = r7 * r6 (int);
84201446:	b1 f0 02 8e 	M[r9 + 8] = rMAC;
        frame_data->total_encoded_data = (uint16)offset;
8420144a:	b6 f0 0b 8c 	MH[r9 + 22] = r4;

8420144e <Lc_sbc_sample_count_17>:
    }
}
8420144e:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201450:	d8 4c       	rts;

84201452 <$_unpack_cbuff_to_array>:
84201452:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
Private Function Definitions
*/

/* unpack_cbuff_to_array */
unsigned int unpack_cbuff_to_array(int *dest, tCbuffer *cbuffer_src, unsigned int amount_to_copy)
{
84201454:	10 09       	r6 = r0 + Null;
84201456:	1e 00       	r4 = r1 + Null;
84201458:	27 00       	r5 = r2 + Null;
    unsigned int available;
    unsigned int usable_octets;

    patch_fn_shared(rtp_decode);
    usable_octets = cbuffer_get_usable_octets(cbuffer_src);
8420145a:	32 00       	r0 = r4 + Null;
8420145c:	ff fd 97 f0 	call (m) 0x14384;
84201460:	29 e9 
84201462:	11 09       	r7 = r0 + Null;

    /* check amount */
    available = cbuffer_calc_amount_data_ex(cbuffer_src);
84201464:	32 00       	r0 = r4 + Null;
84201466:	ff fd db f1 	call (m) 0x3cad6;
8420146a:	31 e3 
    if (available < amount_to_copy)
8420146c:	d0 05       	Null = r0 - r5;
8420146e:	02 f0 87 e0 	if C jump (m) Lc_unpack_cbuff_to_array_3;

84201472 <Lc_unpack_cbuff_to_array_2>:
    {
        amount_to_copy = available;
84201472:	17 00       	r5 = r0 + Null;

84201474 <Lc_unpack_cbuff_to_array_3>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
84201474:	38 04       	Null = r5 - Null;
84201476:	08 60       	if EQ jump (m) Lc_unpack_cbuff_to_array_6;

84201478 <Lc_unpack_cbuff_to_array_4>:
    {
        return amount_to_copy;
    }

    if(usable_octets == 2)
84201478:	90 f0 02 24 	Null = r7 - 2;
8420147c:	07 62       	if NE jump (m) Lc_unpack_cbuff_to_array_7;

8420147e <Lc_unpack_cbuff_to_array_5>:
    {
        /* 16-bit unpacked buffers */
        unpack_cbuff_to_array_16bit(dest, cbuffer_src, amount_to_copy);
8420147e:	3c 00       	r2 = r5 + Null;
84201480:	33 00       	r1 = r4 + Null;
84201482:	42 08       	r0 = r6 + Null;
84201484:	3b 4e       	call (m) $_unpack_cbuff_to_array_16bit;

84201486 <Lc_unpack_cbuff_to_array_6>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
    {
        return amount_to_copy;
84201486:	3a 00       	r0 = r5 + Null;
84201488:	06 6e       	jump (m) Lc_unpack_cbuff_to_array_8;

8420148a <Lc_unpack_cbuff_to_array_7>:
        unpack_cbuff_to_array_16bit(dest, cbuffer_src, amount_to_copy);
    }
    else
    {
        /* 32-bit packed buffers */
        unpack_cbuff_to_array_32bit(dest, cbuffer_src, amount_to_copy);
8420148a:	3c 00       	r2 = r5 + Null;
8420148c:	33 00       	r1 = r4 + Null;
8420148e:	42 08       	r0 = r6 + Null;
84201490:	c0 4e       	call (m) $_unpack_cbuff_to_array_32bit;
84201492:	fa 6f       	jump (m) Lc_unpack_cbuff_to_array_6;

84201494 <Lc_unpack_cbuff_to_array_8>:
    }


    return amount_to_copy;
}
84201494:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201496:	d8 4c       	rts;

84201498 <$_unpack_cbuff_to_array_from_offset>:

/* unpack_cbuff_to_array_from_offset */
unsigned int unpack_cbuff_to_array_from_offset(int *dest, tCbuffer *cbuffer_src,
        unsigned int offset, unsigned int amount_to_copy)
{
84201498:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420149a:	12 09       	r8 = r0 + Null;
8420149c:	18 09       	r6 = r1 + Null;
8420149e:	26 00       	r4 = r2 + Null;
842014a0:	2f 00       	r5 = r3 + Null;
    unsigned int available;
    unsigned int usable_octets;

    patch_fn_shared(rtp_decode);
    usable_octets = cbuffer_get_usable_octets(cbuffer_src);
842014a2:	42 08       	r0 = r6 + Null;
842014a4:	ff fd 97 f0 	call (m) 0x14384;
842014a8:	21 e7 
842014aa:	11 09       	r7 = r0 + Null;

    /* check amount */
    available = cbuffer_calc_amount_data_ex(cbuffer_src);
842014ac:	42 08       	r0 = r6 + Null;
842014ae:	ff fd db f1 	call (m) 0x3cad6;
842014b2:	29 e1 

    if (available <= offset)
842014b4:	90 05       	Null = r0 - r4;
842014b6:	08 f0 89 e0 	if HI jump (m) Lc_unpack_cbuff_to_array_from_offset_3;

842014ba <Lc_unpack_cbuff_to_array_from_offset_2>:
    {
        return 0;
842014ba:	02 00       	r0 = Null + Null;
842014bc:	18 6e       	jump (m) Lc_unpack_cbuff_to_array_from_offset_10;

842014be <Lc_unpack_cbuff_to_array_from_offset_3>:
    }

    if (available < amount_to_copy + offset)
842014be:	b9 01       	rMAC = r5 + r4;
842014c0:	50 04       	Null = r0 - rMAC;
842014c2:	02 f0 87 e0 	if C jump (m) Lc_unpack_cbuff_to_array_from_offset_5;

842014c6 <Lc_unpack_cbuff_to_array_from_offset_4>:
    {
        amount_to_copy = available - offset;
842014c6:	97 05       	r5 = r0 - r4;

842014c8 <Lc_unpack_cbuff_to_array_from_offset_5>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
842014c8:	38 04       	Null = r5 - Null;
842014ca:	09 60       	if EQ jump (m) Lc_unpack_cbuff_to_array_from_offset_8;

842014cc <Lc_unpack_cbuff_to_array_from_offset_6>:
    {
        return amount_to_copy;
    }

    if(usable_octets == 2)
842014cc:	90 f0 02 24 	Null = r7 - 2;
842014d0:	08 62       	if NE jump (m) Lc_unpack_cbuff_to_array_from_offset_9;

842014d2 <Lc_unpack_cbuff_to_array_from_offset_7>:
    {
        /* 16-bit unpacked buffers */
        unpack_cbuff_to_array_from_offset_16bit(dest, cbuffer_src, amount_to_copy,
                                                offset);
842014d2:	35 00       	r3 = r4 + Null;
842014d4:	3c 00       	r2 = r5 + Null;
842014d6:	43 08       	r1 = r6 + Null;
842014d8:	52 08       	r0 = r8 + Null;
842014da:	53 4e       	call (m) $_unpack_cbuff_to_array_from_offset_16bit;

842014dc <Lc_unpack_cbuff_to_array_from_offset_8>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
    {
        return amount_to_copy;
842014dc:	3a 00       	r0 = r5 + Null;
842014de:	07 6e       	jump (m) Lc_unpack_cbuff_to_array_from_offset_10;

842014e0 <Lc_unpack_cbuff_to_array_from_offset_9>:
    }
    else
    {
        /* 32-bit packed buffers */
        unpack_cbuff_to_array_from_offset_32bit(dest, cbuffer_src, amount_to_copy,
                                                offset);
842014e0:	35 00       	r3 = r4 + Null;
842014e2:	3c 00       	r2 = r5 + Null;
842014e4:	43 08       	r1 = r6 + Null;
842014e6:	52 08       	r0 = r8 + Null;
842014e8:	ca 4e       	call (m) $_unpack_cbuff_to_array_from_offset_32bit;
842014ea:	f9 6f       	jump (m) Lc_unpack_cbuff_to_array_from_offset_8;

842014ec <Lc_unpack_cbuff_to_array_from_offset_10>:
    }
    return amount_to_copy;
}
842014ec:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842014ee:	d8 4c       	rts;

842014f0 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_rtp_decode_cap_data;
842014f0:	07 f0 02 f0 	r0 = Null + 7340032;
842014f4:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
842014f6:	20 f0 f8 42 	Null = Null + 17144;

842014fa <$_unpack_cbuff_to_array_16bit>:
842014fa:	29 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, r7, rLink>;
// M2 = -ADDR_PER_WORD
// trashed r3
$_unpack_cbuff_to_array_16bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
842014fe:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // uset the dest as a buffer with size of the amount
   I4 = r0;
84201502:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
84201504:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
84201506:	26 0b       	L4 = r2 + Null;
   push r0;
84201508:	00 f0 32 cf 	push r0;
   pop B4;
8420150c:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
84201510:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
84201512:	ff fd da f1 	call (m) 0x3c9d6;
84201516:	25 e6 
   I0 = r0;
84201518:	10 0a       	I0 = r0 + Null;
   L0 = r2;
8420151a:	24 0b       	L0 = r2 + Null;
   push r3;
8420151c:	00 f0 35 cf 	push r3;
   pop B0;
84201520:	00 f6 3a cf 	pop B0;

   r7 =  M[FP + 3*ADDR_PER_WORD];       // copy amount
84201524:	e9 f0 03 88 	r7 = M[FP + 12];
   Null = r1;                           // r1 is the read offset
84201528:	18 00       	Null = r1 + Null;

   if Z jump copy_unpacked_no_read_offset;
8420152a:	08 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpacked_no_read_offset;
   // read the first byte
   r5 = M[I0, ADDR_PER_WORD];
8420152c:	71 f0 30 c0 	Null = Null + Null, r5 = M[I0,4];
   r5 = r5 AND 0xff;
84201530:	bf c3       	r5 = r5 AND 0xff;
   M[I4, ADDR_PER_WORD] = r5;
84201532:	f1 f0 30 d0 	Null = Null + Null, M[I4,4] = r5;
   r7 = r7 - 1;                         // one octet was read so subtract it
84201536:	99 f0 01 24 	r7 = r7 - 1;

8420153a <$M.unpack_cbuff_to_array_c_stubs.copy_unpacked_no_read_offset>:

   copy_unpacked_no_read_offset:

   r10 = r7 LSHIFT -1;                  // translate to words
8420153a:	7f f9 dc d8 	r10 = r7 LSHIFT -1;

   r0 = 0xFF;                           // set r0 to a constant for masking the bottom octets
8420153e:	02 f0 ff 40 	r0 = Null + 255;
   r1 = M[I0, M1];                      // read the first word
84201542:	31 f0 20 c0 	Null = Null + Null, r1 = M[I0,M1];

   do copy_unpack_loop;
84201546:	07 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop;
      r2 = r1 LSHIFT -8;                // set r2 as the higher octet from the read word
84201548:	dc 51       	r2 = r1 LSHIFT -8;
      r1 = r1 AND r0,                   // set r1 as the lower octet from the read word
       M[I4, M1] = r2;                  // write the higher octet to the memory
8420154a:	00 f0 c1 f2 	r1 = r1 AND r0, M[I4,M1] = r2;
8420154e:	23 c8 
      M[I4, M1] = r1,                   // write the lower octet to the memory
       r1 = M[I0, M1];                  // read the next word
84201550:	b1 f1 23 d0 	Null = Null + Null, r1 = M[I0,M1], M[I4,M1] = r1;

84201554 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop>:
   copy_unpack_loop:

   r1 = M[I0, M2];                       // compensate for the additional read
84201554:	32 f0 20 c0 	Null = Null + Null, r1 = M[I0,M2];

   // write the carry over if neccessary
   Null = r7 AND 0x1;
84201558:	90 f0 01 00 	Null = r7 AND 0x1;
   if Z jump copy_unpack_copy_done;
8420155c:	06 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_copy_done;

   r2 = M[I0, 0];
8420155e:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
   r2 = r2 LSHIFT -8;
84201562:	e4 51       	r2 = r2 LSHIFT -8;
   M[I4,ADDR_PER_WORD] = r2;
84201564:	c1 f0 30 d0 	Null = Null + Null, M[I4,4] = r2;

84201568 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_copy_done>:

   copy_unpack_copy_done:


   // Update the read address
   r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201568:	12 d8       	r0 = M[FP + 8];
   r1 = I0;
8420156a:	83 08       	r1 = I0 + Null;
   r2 = r7 AND 0x1;                             // offset
8420156c:	94 f0 01 00 	r2 = r7 AND 0x1;
   call $cbuffer.set_read_address_ex;
84201570:	ff fd db f1 	call (m) 0x3cbbc;
84201574:	2d e2 

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
84201576:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r5, r7, rLink>;
8420157a:	29 f2 6d e0 	popm <FP, r0, r1, r2, r5, r7, rLink>;
   rts;
8420157e:	d8 4c       	rts;

84201580 <$_unpack_cbuff_to_array_from_offset_16bit>:
// (int *dest, tCbuffer *src, unsigned int amount_to_copy, unsigned offset);
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
$_unpack_cbuff_to_array_from_offset_16bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
84201580:	2b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
84201584:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // use the dest as a buffer with size of the amount
   I4 = r0;
84201588:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
8420158a:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
8420158c:	26 0b       	L4 = r2 + Null;
   push r0;
8420158e:	00 f0 32 cf 	push r0;
   pop B4;
84201592:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
84201596:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
84201598:	ff fd da f1 	call (m) 0x3c9d6;
8420159c:	3f e1 
   I0 = r0;
8420159e:	10 0a       	I0 = r0 + Null;
   L0 = r2;
842015a0:	24 0b       	L0 = r2 + Null;
   push r3;
842015a2:	00 f0 35 cf 	push r3;
   pop B0;
842015a6:	00 f6 3a cf 	pop B0;

   // Advance the read pointer
   r7 = M[FP + 4*ADDR_PER_WORD];        // offset input
842015aa:	e9 f0 04 88 	r7 = M[FP + 16];
   r7 = r7 + r1;
842015ae:	19 0d       	r7 = r1 + r7;
   r1 = r7 AND 0x1;                     // get the new offset
842015b0:	93 f0 01 00 	r1 = r7 AND 0x1;
   r7 = r7 LSHIFT -1;                   // get the words
842015b4:	7f f9 d9 d8 	r7 = r7 LSHIFT -1;
   r7 = r7 LSHIFT LOG2_ADDR_PER_WORD;   // get the octets from words - only 16bit unpacked
842015b8:	01 f9 d9 c8 	r7 = r7 LSHIFT 2;
   M3 = r7;
842015bc:	4b 0b       	M3 = r7 + Null;
   r0 = M[I0, M3];  // advancing the read pointer.
842015be:	23 f0 20 c0 	Null = Null + Null, r0 = M[I0,M3];


   r7 =  M[FP + 3*ADDR_PER_WORD];              // copy amount
842015c2:	e9 f0 03 88 	r7 = M[FP + 12];
   Null = r1;                                  // r1 is the read offset
842015c6:	18 00       	Null = r1 + Null;

   if Z jump copy_unpack_from_offset_no_read_offset;
842015c8:	08 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_no_read_offset;
   // read the first byte
   r5 = M[I0, ADDR_PER_WORD];
842015ca:	71 f0 30 c0 	Null = Null + Null, r5 = M[I0,4];
   r5 = r5 AND 0xff;
842015ce:	bf c3       	r5 = r5 AND 0xff;
   M[I4, ADDR_PER_WORD] = r5;
842015d0:	f1 f0 30 d0 	Null = Null + Null, M[I4,4] = r5;
   r7 = r7 - 1;                                 // one octet copied so subtract it
842015d4:	99 f0 01 24 	r7 = r7 - 1;

842015d8 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_no_read_offset>:

   copy_unpack_from_offset_no_read_offset:

   r10 = r7 LSHIFT -1;                          // translate to words
842015d8:	7f f9 dc d8 	r10 = r7 LSHIFT -1;

   r0 = 0xFF;                            // set r0 to a constant for masking the bottom octets
842015dc:	02 f0 ff 40 	r0 = Null + 255;
   r1 = M[I0, M1];                       // read the first word
842015e0:	31 f0 20 c0 	Null = Null + Null, r1 = M[I0,M1];

   do copy_unpack_from_offset_loop;
842015e4:	07 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop;
      r2 = r1 LSHIFT -8;                // set r2 as the higher octet from the read word
842015e6:	dc 51       	r2 = r1 LSHIFT -8;
      r1 = r1 AND r0,                   // set r1 as the lower octet from the read word
       M[I4, M1] = r2;                  // write the higher octet to the memory
842015e8:	00 f0 c1 f2 	r1 = r1 AND r0, M[I4,M1] = r2;
842015ec:	23 c8 

      M[I4, M1] = r1,                   // write the lower octet to the memory
       r1 = M[I0, M1];                  // read the next word
842015ee:	b1 f1 23 d0 	Null = Null + Null, r1 = M[I0,M1], M[I4,M1] = r1;

842015f2 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop>:
   copy_unpack_from_offset_loop:

   r1 = M[I0, M2];                      // compensate for the additional read
842015f2:	32 f0 20 c0 	Null = Null + Null, r1 = M[I0,M2];

   // write the carry over if neccessary
   Null = r7 AND 0x1;
842015f6:	90 f0 01 00 	Null = r7 AND 0x1;
   if Z jump copy_unpack_from_offset_copy_done;
842015fa:	06 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_copy_done;

   r2 = M[I0, 0];
842015fc:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
   r2 = r2 LSHIFT -8;
84201600:	e4 51       	r2 = r2 LSHIFT -8;
   M[I4, ADDR_PER_WORD] = r2;
84201602:	c1 f0 30 d0 	Null = Null + Null, M[I4,4] = r2;

84201606 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_copy_done>:

   copy_unpack_from_offset_copy_done:

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
84201606:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
8420160a:	2b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
   rts;
8420160e:	d8 4c       	rts;

84201610 <$_unpack_cbuff_to_array_32bit>:
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
// trashed r3
$_unpack_cbuff_to_array_32bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, rLink>;
84201610:	0b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, rLink>;
   pushm <I0, I4, L0, L4>;
84201614:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // uset the dest as a buffer with size of the amount
   I4 = r0;
84201618:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
8420161a:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
8420161c:	26 0b       	L4 = r2 + Null;
   push r0;
8420161e:	00 f0 32 cf 	push r0;
   pop B4;
84201622:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
84201626:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
84201628:	ff fd d9 f1 	call (m) 0x3c9d6;
8420162c:	2f ed 
   I0 = r0;
8420162e:	10 0a       	I0 = r0 + Null;
   L0 = r2;
84201630:	24 0b       	L0 = r2 + Null;
   push r3;
84201632:	00 f0 35 cf 	push r3;
   pop B0;
84201636:	00 f6 3a cf 	pop B0;

   r3 = 0x3;
8420163a:	c5 20       	r3 = Null + 3;
   r10 =  M[FP + 3*ADDR_PER_WORD];    // copy amount
8420163c:	ec f0 03 88 	r10 = M[FP + 12];
   r0 = 0xFF;
84201640:	02 f0 ff 40 	r0 = Null + 255;
   do copy_unpack_loop_32bit;
84201644:	11 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop_32bit;
       r5 = r3 - r1;
84201646:	ef 04       	r5 = r3 - r1;
       r5 = r5 LSHIFT 3;
84201648:	bf 54       	r5 = r5 LSHIFT 3;
       r5 = -r5;                      // shift amount for source word
8420164a:	c7 05       	r5 = Null - r5;

       r2 = M[I0, 0];
8420164c:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
       r2 = r2 LSHIFT r5;             // shift octet left to LS position
84201650:	e4 17       	r2 = r2 LSHIFT r5;
       r1 = r1 + 1;
84201652:	5b 20       	r1 = r1 + 1;
       Null = ADDR_PER_WORD - r1;
84201654:	02 f3 50 c6 	Null = 4 - r1;
       if NZ jump continue_masking;
84201658:	04 62       	if NE jump (m) $M.unpack_cbuff_to_array_c_stubs.continue_masking;
           r1 = 0;
8420165a:	03 00       	r1 = Null + Null;
           r5 = M[I0, M1];            // advance one word
8420165c:	71 f0 20 c0 	Null = Null + Null, r5 = M[I0,M1];

84201660 <$M.unpack_cbuff_to_array_c_stubs.continue_masking>:

       continue_masking:
       r2 = r2 AND r0;
84201660:	a4 10       	r2 = r2 AND r0;

       M[I4, M1] = r2;
84201662:	c1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r2;

84201666 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop_32bit>:

   copy_unpack_loop_32bit:

   // Update the read address
   r0 = M[FP + 2*ADDR_PER_WORD];      // cbuffer_src
84201666:	12 d8       	r0 = M[FP + 8];
   r2 = r1;                           // offset
84201668:	1c 00       	r2 = r1 + Null;
   r1 = I0;
8420166a:	83 08       	r1 = I0 + Null;
   call $cbuffer.set_read_address_ex;
8420166c:	ff fd da f1 	call (m) 0x3cbbc;
84201670:	31 ea 

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
84201672:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, rLink>;
84201676:	0b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, rLink>;
   rts;
8420167a:	d8 4c       	rts;

8420167c <$_unpack_cbuff_to_array_from_offset_32bit>:
// (int *dest, tCbuffer *src, unsigned int amount_to_copy, unsigned offset);
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
$_unpack_cbuff_to_array_from_offset_32bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
8420167c:	2b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
84201680:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // use the dest as a buffer with size of the amount
   I4 = r0;
84201684:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
84201686:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
84201688:	26 0b       	L4 = r2 + Null;
   push r0;
8420168a:	00 f0 32 cf 	push r0;
   pop B4;
8420168e:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                           // cbuffer_src
84201692:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
84201694:	ff fd d9 f1 	call (m) 0x3c9d6;
84201698:	23 ea 
   I0 = r0;
8420169a:	10 0a       	I0 = r0 + Null;
   L0 = r2;
8420169c:	24 0b       	L0 = r2 + Null;
   push r3;
8420169e:	00 f0 35 cf 	push r3;
   pop B0;
842016a2:	00 f6 3a cf 	pop B0;


   // Advance the read pointer
   r7 = M[FP + 4*ADDR_PER_WORD];      // offset input
842016a6:	e9 f0 04 88 	r7 = M[FP + 16];
   r7 = r7 + r1;
842016aa:	19 0d       	r7 = r1 + r7;

   r3 = 0x3;
842016ac:	c5 20       	r3 = Null + 3;
   r1 = r7 AND r3;                    // get the new offset
842016ae:	5f f9 03 c8 	r1 = r7 AND r3;

   r7 = r7 AND 0xFFFFFFFC;            // remove the offset from the octets
842016b2:	99 ff fc 1f 	r7 = r7 AND 0xfffffffc;
   M3 = r7;
842016b6:	4b 0b       	M3 = r7 + Null;
   r0 = M[I0, M3];                    // advancing the read pointer.
842016b8:	23 f0 20 c0 	Null = Null + Null, r0 = M[I0,M3];

   r10 =  M[FP + 3*ADDR_PER_WORD];    // copy amount
842016bc:	ec f0 03 88 	r10 = M[FP + 12];
   r0 = 0xFF;
842016c0:	02 f0 ff 40 	r0 = Null + 255;
   do copy_unpack_from_offset_loop_32bit;
842016c4:	11 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop_32bit;
       r5 = r3 - r1;
842016c6:	ef 04       	r5 = r3 - r1;
       r5 = r5 LSHIFT 3;
842016c8:	bf 54       	r5 = r5 LSHIFT 3;
       r5 = -r5;                      // shift amount for source word
842016ca:	c7 05       	r5 = Null - r5;

       r2 = M[I0, 0];
842016cc:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
       r2 = r2 LSHIFT r5;             // shift octet left to LS position
842016d0:	e4 17       	r2 = r2 LSHIFT r5;
       r1 = r1 + 1;
842016d2:	5b 20       	r1 = r1 + 1;
       Null = ADDR_PER_WORD - r1;
842016d4:	02 f3 50 c6 	Null = 4 - r1;
       if NZ jump continue_masking_from_offset;
842016d8:	04 62       	if NE jump (m) $M.unpack_cbuff_to_array_c_stubs.continue_masking_from_offset;
           r1 = 0;
842016da:	03 00       	r1 = Null + Null;
           r5 = M[I0, M1];
842016dc:	71 f0 20 c0 	Null = Null + Null, r5 = M[I0,M1];

842016e0 <$M.unpack_cbuff_to_array_c_stubs.continue_masking_from_offset>:

       continue_masking_from_offset:
       r2 = r2 AND r0;
842016e0:	a4 10       	r2 = r2 AND r0;

       M[I4, M1] = r2;
842016e2:	c1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r2;

842016e6 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop_32bit>:

   copy_unpack_from_offset_loop_32bit:

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
842016e6:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
842016ea:	2b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
   rts;
842016ee:	d8 4c       	rts;

842016f0 <$_ttp_configure_sp_adjustment>:
842016f0:	01 f1 00 88 	rMAC = M[Null + 0x2000];
.MINIM;

$_ttp_configure_sp_adjustment:
#ifdef ENTRY_POINT_TTP_CONFIGURE_SP_ADJUSTMENT
    rMAC = M[$_patched_fw_version];
    Null = rMAC - PATCH_BUILD_ID;
842016f4:	00 f0 10 f3 	Null = rMAC - 15894;
842016f8:	16 3e 
    if EQ jump ENTRY_POINT_TTP_CONFIGURE_SP_ADJUSTMENT;
842016fa:	fc ff 20 f0 	if EQ jump (m) 0x40027f8;
842016fe:	ff e1 

84201700 <$M.download_support_lib.ttp_configure_sp_adjustment.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84201700:	02 00       	r0 = Null + Null;
    rts;
84201702:	d8 4c       	rts;

84201704 <$_ttp_adjust_ttp_timestamp>:
.CODESEGMENT PM;
.MINIM;

$_ttp_adjust_ttp_timestamp:
#ifdef ENTRY_POINT_TTP_ADJUST_TTP_TIMESTAMP
    rMAC = M[$_patched_fw_version];
84201704:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201708:	00 f0 10 f3 	Null = rMAC - 15894;
8420170c:	16 3e 
    if EQ jump ENTRY_POINT_TTP_ADJUST_TTP_TIMESTAMP;
8420170e:	fc ff 20 f0 	if EQ jump (m) 0x400280a;
84201712:	fd e1 

84201714 <$M.download_support_lib.ttp_adjust_ttp_timestamp.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84201714:	02 00       	r0 = Null + Null;
    rts;
84201716:	d8 4c       	rts;

84201718 <$_ttp_get_msg_state_params>:
.CODESEGMENT PM;
.MINIM;

$_ttp_get_msg_state_params:
#ifdef ENTRY_POINT_TTP_GET_MSG_STATE_PARAMS
    rMAC = M[$_patched_fw_version];
84201718:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
8420171c:	00 f0 10 f3 	Null = rMAC - 15894;
84201720:	16 3e 
    if EQ jump ENTRY_POINT_TTP_GET_MSG_STATE_PARAMS;
84201722:	fc ff 20 f0 	if EQ jump (m) 0x4002822;
84201726:	81 e2 

84201728 <$M.download_support_lib.ttp_get_msg_state_params.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84201728:	02 00       	r0 = Null + Null;
    rts;
8420172a:	d8 4c       	rts;

8420172c <$_ttp_configure_state_params>:
.CODESEGMENT PM;
.MINIM;

$_ttp_configure_state_params:
#ifdef ENTRY_POINT_TTP_CONFIGURE_STATE_PARAMS
    rMAC = M[$_patched_fw_version];
8420172c:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201730:	00 f0 10 f3 	Null = rMAC - 15894;
84201734:	16 3e 
    if EQ jump ENTRY_POINT_TTP_CONFIGURE_STATE_PARAMS;
84201736:	fc ff 20 f0 	if EQ jump (m) 0x4002872;
8420173a:	bd e2 

8420173c <$M.download_support_lib.ttp_configure_state_params.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
8420173c:	02 00       	r0 = Null + Null;
    rts;
8420173e:	d8 4c       	rts;

84201740 <$_ttp_get_state_params_status>:
.CODESEGMENT PM;
.MINIM;

$_ttp_get_state_params_status:
#ifdef ENTRY_POINT_TTP_GET_STATE_PARAMS_STATUS
    rMAC = M[$_patched_fw_version];
84201740:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84201744:	00 f0 10 f3 	Null = rMAC - 15894;
84201748:	16 3e 
    if EQ jump ENTRY_POINT_TTP_GET_STATE_PARAMS_STATUS;
8420174a:	fc ff 20 f0 	if EQ jump (m) 0x400291e;
8420174e:	d5 e3 

84201750 <$M.download_support_lib.ttp_get_state_params_status.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84201750:	02 00       	r0 = Null + Null;
    rts;
84201752:	d8 4c       	rts;

84201754 <$M.download_support_lib.ttp_get_msg_sp_adjustment.L_pb_mismatch>:
    Null = rMAC - PATCH_BUILD_ID;
    if EQ jump ENTRY_POINT_TTP_GET_MSG_SP_ADJUSTMENT;
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84201754:	02 00       	r0 = Null + Null;
    rts;
84201756:	d8 4c       	rts;

84201758 <$_ttp_get_msg_adjust_ttp_timestamp>:
.CODESEGMENT PM;
.MINIM;

$_ttp_get_msg_adjust_ttp_timestamp:
#ifdef ENTRY_POINT_TTP_GET_MSG_ADJUST_TTP_TIMESTAMP
    rMAC = M[$_patched_fw_version];
84201758:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
8420175c:	00 f0 10 f3 	Null = rMAC - 15894;
84201760:	16 3e 
    if EQ jump ENTRY_POINT_TTP_GET_MSG_ADJUST_TTP_TIMESTAMP;
84201762:	fc ff 20 f0 	if EQ jump (m) 0x40027ea;
84201766:	89 e1 

84201768 <$M.download_support_lib.ttp_get_msg_adjust_ttp_timestamp.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84201768:	02 00       	r0 = Null + Null;
    rts;
8420176a:	d8 4c       	rts;
